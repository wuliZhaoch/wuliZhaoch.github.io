<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Altium Designer】学习笔记 --&gt; Altium Designer 导出 Gerber 文件教程</title>
    <url>/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<h2 id="Altium-Designer-导出-Gerber-文件教程"><a href="#Altium-Designer-导出-Gerber-文件教程" class="headerlink" title="Altium Designer 导出 Gerber 文件教程"></a>Altium Designer 导出 Gerber 文件教程</h2><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>输出的Gerber不是一个文件，而是一个文件集合，通常需要打包发送给厂家，厂家根据你输出的要求进行打样。基本输出的文件大概有这几个流程 Gerber Files、NC Drill Files(钻孔文件)、BOM(元器件BOM)、Generates Pick and Place Files(坐标文件)，具体步骤如下。</p>
<h4 id="2-添加钻孔表"><a href="#2-添加钻孔表" class="headerlink" title="2. 添加钻孔表"></a>2. 添加钻孔表</h4><h5 id="2-1-选中-Drill-Drawing-层"><a href="#2-1-选中-Drill-Drawing-层" class="headerlink" title="2.1 选中 Drill Drawing 层"></a>2.1 选中 Drill Drawing 层</h5><p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/DrillDrawing.png" alt></p>
<h5 id="2-2-在此层放置“-legend-”-字符"><a href="#2-2-在此层放置“-legend-”-字符" class="headerlink" title="2.2 在此层放置“ .legend ” 字符"></a>2.2 在此层放置“ .legend ” 字符</h5><ul>
<li><p>单击放置字符串</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/String.png" alt="String"></p>
</li>
<li><p>放置 “ .legend ” 字符 </p>
<ul>
<li>放置“ .legend ”字符后，在第一次输出Gerber文件的时候，会自动生产一个钻孔表，效果如 2.4 - 2 图。 </li>
</ul>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Legend.png" alt="legend"></p>
</li>
</ul>
<h5 id="2-3-字符放置效果"><a href="#2-3-字符放置效果" class="headerlink" title="2.3 字符放置效果"></a>2.3 字符放置效果</h5><p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Placetheeffect.png" alt="Place the effect"></p>
<h5 id="2-4-如果以上方法不行，该如何操作？-具体原因可能是版本问题，毕竟用的破解版的"><a href="#2-4-如果以上方法不行，该如何操作？-具体原因可能是版本问题，毕竟用的破解版的" class="headerlink" title="2.4 如果以上方法不行，该如何操作？(具体原因可能是版本问题，毕竟用的破解版的)"></a>2.4 如果以上方法不行，该如何操作？(具体原因可能是版本问题，毕竟用的破解版的)</h5><p>在Altium Designer 的菜单中选择 Place (放置) -&gt; Dirll Table(钻孔表) 。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/drilltable.png" alt="drilltable"></p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/drilltable1.png" alt="drilltable1"></p>
<h4 id="3-第一次输出（Gerber-Files）"><a href="#3-第一次输出（Gerber-Files）" class="headerlink" title="3. 第一次输出（Gerber Files）"></a>3. 第一次输出（Gerber Files）</h4><p>打开要导出的PCB，在 Altium Designer 的菜单中选择 File(文件) -&gt; Fabrication(输出制造文件) -&gt; Gerber Files。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/File-Fabrication-Gerber.png" alt="File-Fabrication-Gerber"></p>
<h5 id="3-1-Gerber-Setup-gt-General-设置"><a href="#3-1-Gerber-Setup-gt-General-设置" class="headerlink" title="3.1 Gerber Setup -&gt; General 设置"></a>3.1 Gerber Setup -&gt; General 设置</h5><p>Units (单位) 选择 <strong>Inches (英寸)</strong>；Formal (格式) 选择 <strong>2:5</strong>；根据介绍 <strong>2:3</strong> 分辨率 1mil，<strong>2:4</strong> 分辨率 0.1mil，<strong>2:5</strong> 分辨率 0.01mil；2:5 精度相对较高，本人用这个设置在多个厂家打样都没有任何问题。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/General.png" alt="General"></p>
<h5 id="3-2-Gerber-Setup-gt-Layers-设置"><a href="#3-2-Gerber-Setup-gt-Layers-设置" class="headerlink" title="3.2 Gerber Setup -&gt; Layers 设置"></a>3.2 Gerber Setup -&gt; Layers 设置</h5><p>​        单击 Plot Layers 选择 Used no 后，只要在 Layers To Plot 栏里的层都会被选中，勾选掉 Top Pad Master、Bottom Pad Master 两层，然后根据自己需要导出的层进行选择 <strong>(嘉立创现在识别版边框为 Mechanical 1 机械1层)</strong>，所以导出要选择 Mechanical 1 层；勾选 <strong>Include unconnected mid-layer pads</strong>。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Layers.png" alt="Layers"></p>
<h5 id="3-3-Gerber-Setup-gt-Drill-Drawing-设置"><a href="#3-3-Gerber-Setup-gt-Drill-Drawing-设置" class="headerlink" title="3.3 Gerber Setup -&gt; Drill Drawing 设置"></a>3.3 Gerber Setup -&gt; Drill Drawing 设置</h5><p>Drill Drawing选项卡中 需要在 <strong>Drill Drawing Plots</strong> 和 <strong>Drill Guide Plots</strong> 两个区域勾选 <strong>Plot all used drill pairs</strong></p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Drill.png" alt="Drill"></p>
<h5 id="3-4-Gerber-Setup-gt-Apertures-设置"><a href="#3-4-Gerber-Setup-gt-Apertures-设置" class="headerlink" title="3.4 Gerber Setup -&gt; Apertures 设置"></a>3.4 Gerber Setup -&gt; Apertures 设置</h5><p>在 Apertures (光圈)选项卡中勾选 Embedded apertures (RS274X) 即可。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Apertures.png" alt="Apertures"></p>
<h5 id="3-5-Gerber-Setup-gt-Advanced-设置"><a href="#3-5-Gerber-Setup-gt-Advanced-设置" class="headerlink" title="3.5 Gerber Setup -&gt; Advanced 设置"></a>3.5 Gerber Setup -&gt; Advanced 设置</h5><p>在 Advanced 选项卡中需要在 Film Size 区域中的每个选项中添加一个0; 其他的默认即合。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Advanced.png" alt="Advanced"></p>
<h5 id="3-6-Gerber-Files-输出结束后效果"><a href="#3-6-Gerber-Files-输出结束后效果" class="headerlink" title="3.6 Gerber Files 输出结束后效果"></a>3.6 Gerber Files 输出结束后效果</h5><p>第一次输出结束后自动生成 CAMtastic1.Cam*的 CAM加工文件，不用保存可以立即关闭并丢弃。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/CAM.png" alt="CAM"></p>
<h4 id="4-第二次输出（NC-Drill-Files）"><a href="#4-第二次输出（NC-Drill-Files）" class="headerlink" title="4. 第二次输出（NC Drill Files）"></a>4. 第二次输出（NC Drill Files）</h4><p>打开要导出的PCB，在 Altium Designer 的菜单中选择 File(文件) -&gt; Fabrication(输出制造文件) -&gt; NC Drill Files。</p>
<h5 id="4-1-NC-Drill-Setup-选项卡设置"><a href="#4-1-NC-Drill-Setup-选项卡设置" class="headerlink" title="4.1 NC Drill Setup 选项卡设置"></a>4.1 NC Drill Setup 选项卡设置</h5><p>通常默认设置即可，只有两个地方需要修改 —-&gt; Leading/Trailing Zeroes 区域选择 <strong>Suppress leading zeroes</strong>，默认 Suppress trailing zeroes；Other 区域勾选 <strong>Generate EIA Binary Drill File (.DRL)</strong>。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/NCDrill.png" alt="NC Drill"></p>
<h5 id="4-2-Import-Drill-Data-导入钻孔数据-窗口"><a href="#4-2-Import-Drill-Data-导入钻孔数据-窗口" class="headerlink" title="4.2 Import Drill Data (导入钻孔数据)窗口"></a>4.2 Import Drill Data (导入钻孔数据)窗口</h5><p>默认即可，不用修改，直接点击OK进行输出</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/ImportDrillData.png" alt="Import Drill Data"></p>
<h4 id="5-第三次输出（Generates-Pick-and-Place-Files）"><a href="#5-第三次输出（Generates-Pick-and-Place-Files）" class="headerlink" title="5. 第三次输出（Generates Pick and Place Files）"></a>5. 第三次输出（Generates Pick and Place Files）</h4><p>打开要导出的PCB，在 Altium Designer 的菜单中选择 File(文件) -&gt; Assembly(输出装配文件) -&gt; Generates Pick and Place Files。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Generates.png" alt="Generates"></p>
<h5 id="5-1-Pick-and-Place-Setup-设置"><a href="#5-1-Pick-and-Place-Setup-设置" class="headerlink" title="5.1 Pick and Place Setup 设置"></a>5.1 Pick and Place Setup 设置</h5><p>左边选项卡中必须要勾选的几个参数 <strong>Center-X</strong> 、<strong>Center-Y</strong>、<strong>Pad-X</strong>、<strong>Pad-Y</strong>、<strong>Ref-X</strong>、<strong>Ref-Y</strong>、<strong>Rotation</strong>，其他根据需求选择。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Generates1.png" alt="Generates1"></p>
<h5 id="5-2-坐标文件-csv-修改"><a href="#5-2-坐标文件-csv-修改" class="headerlink" title="5.2 坐标文件 .csv 修改"></a>5.2 坐标文件 .csv 修改</h5><p>删除表头文件设计信息<strong>（红线以上全部删除Delete）</strong></p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/%E5%9D%90%E6%A0%87csv%E6%96%87%E4%BB%B6.png" alt="坐标csv文件"></p>
<h4 id="6-第四次输出（PCB-BOM表）"><a href="#6-第四次输出（PCB-BOM表）" class="headerlink" title="6. 第四次输出（PCB BOM表）"></a>6. 第四次输出（PCB BOM表）</h4><p>在 Altium Designer 的菜单中选择 Reports(报告) -&gt; Bill of Materials。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Reports.png" alt="Reports"></p>
<h5 id="6-1-Properties-gt-General-设置"><a href="#6-1-Properties-gt-General-设置" class="headerlink" title="6.1 Properties -&gt; General 设置"></a>6.1 Properties -&gt; General 设置</h5><p>设置输出文件格式</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/BOM-General.png" alt="BOM_General"></p>
<h5 id="6-2-Properties-gt-Columns设置"><a href="#6-2-Properties-gt-Columns设置" class="headerlink" title="6.2 Properties -&gt; Columns设置"></a>6.2 Properties -&gt; Columns设置</h5><p>添加<strong>Pins</strong>参数信息</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/BOM-Columns.png" alt="BOM-Columns"></p>
<h4 id="7-Gerber-文件整理"><a href="#7-Gerber-文件整理" class="headerlink" title="7. Gerber 文件整理"></a>7. Gerber 文件整理</h4><h5 id="7-1-PCB工程文件夹下创建两个文件夹-SMT-、Gerber"><a href="#7-1-PCB工程文件夹下创建两个文件夹-SMT-、Gerber" class="headerlink" title="7.1 PCB工程文件夹下创建两个文件夹 SMT 、Gerber"></a>7.1 PCB工程文件夹下创建两个文件夹 SMT 、Gerber</h5><p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/folder.png" alt="folder"></p>
<h5 id="7-2-输出Gerber文件添加到Gerber文件夹"><a href="#7-2-输出Gerber文件添加到Gerber文件夹" class="headerlink" title="7.2 输出Gerber文件添加到Gerber文件夹"></a>7.2 输出Gerber文件添加到Gerber文件夹</h5><p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Gerberfoler.png" alt="Gerberfoler"></p>
<h5 id="7-3-坐标文件、BOM、钢网层添加到SMT文件夹"><a href="#7-3-坐标文件、BOM、钢网层添加到SMT文件夹" class="headerlink" title="7.3 坐标文件、BOM、钢网层添加到SMT文件夹"></a>7.3 坐标文件、BOM、钢网层添加到SMT文件夹</h5><p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/SMTPaste.png" alt="SMTPaste"></p>
<h4 id="8-Altium-Designer-导出-Gerber文件教程完毕"><a href="#8-Altium-Designer-导出-Gerber文件教程完毕" class="headerlink" title="8. Altium Designer 导出 Gerber文件教程完毕"></a>8. Altium Designer 导出 Gerber文件教程完毕</h4><p> <a href="http://www.linelayout.com/bbs/bbs/uploadfile/image/20140917154916101610.pdf" target="_blank" rel="noopener">参考连接</a></p>
]]></content>
      <categories>
        <category>Altium Designer</category>
        <category>Gerber</category>
      </categories>
      <tags>
        <tag>Gerber</tag>
        <tag>PCB_Design</tag>
      </tags>
  </entry>
  <entry>
    <title>【nRF52832】学习笔记 --&gt; GPIOTE (TASK/EVENT)</title>
    <url>/2020/08/06/GPIOTE/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<p>环境介绍</p>
<ul>
<li>操作系统:   Window10 企业版</li>
<li>IDE开发环境:   ARM_MDK5 (Keil5)</li>
<li>SDK版本:   SDK_17.0.0 </li>
<li>硬件开发板:   官方开发板 PCA10040</li>
</ul>
<a id="more"></a>

<h2 id="GPIOTE-TASK-EVENT"><a href="#GPIOTE-TASK-EVENT" class="headerlink" title="GPIOTE (TASK/EVENT)"></a>GPIOTE (TASK/EVENT)</h2><h4 id="1-概述介绍"><a href="#1-概述介绍" class="headerlink" title="1. 概述介绍"></a>1. 概述介绍</h4><p>  GPIOTE 驱动控制 GPIO 和 GPIOTE 外设,并配置和控制输出和输入引脚。可以将输出引脚配置为手动控制或者通过 GPIOTE 任务进行控制。输入引脚可以配置在不同模式下进行控制。</p>
<h4 id="2-GPIOTE-功能"><a href="#2-GPIOTE-功能" class="headerlink" title="2. GPIOTE 功能"></a>2. GPIOTE 功能</h4><p>&emsp;&emsp;nRF52832 的GPIOTE共有8个通道，每个通道否可以分配给一个引脚，分配的引脚可以配置为任务模式或时间模式。不能将某个引脚同事分配给多个GPIOTE通道，否则会导致无法预料的错误。</p>
<ul>
<li>GPIOTE 每个通道有Set、Clear和Out三个任务，Set和Clear任务对引脚时固定操作，Out 任务可以引脚PIN执行以下操作：<ul>
<li>Set  (置位  输出高电平)</li>
<li>Clear (清零 输出低电平 )</li>
<li>Toggle (翻转)</li>
</ul>
</li>
<li>GPIOTE 模块遵循以下输入条件之一，GPIOTE每个通道产生事件：<ul>
<li>Rising edge (上升沿)</li>
<li>Falling edge (下降沿)</li>
<li>Any change (任意电平跳变)</li>
</ul>
</li>
</ul>
<h4 id="3-PIN-Events-and-Tasks-引脚事件和任务"><a href="#3-PIN-Events-and-Tasks-引脚事件和任务" class="headerlink" title="3. PIN Events and Tasks (引脚事件和任务)"></a>3. PIN Events and Tasks (引脚事件和任务)</h4><ul>
<li>GPIOTE模块有许多任务和事件，可以配置GPIOTE模块对单个任务红外事件进行操作GPIO Pin。</li>
<li>任务(Set[n]、Clr[n]、Out[n])可用于向单个引脚写入，而事件(IN[n])可有单个引脚输入处发生的变化生成。</li>
<li>GPIOTE通带被配置用于操作一个任务引脚时，引脚的初始状态时可以配置的，可以通过配置CONFIG[n]寄存器中OUTINIT来设置引脚初始化状态为高电平或低电平。</li>
<li>同一个GPIOTE通道中同时触发了有冲突的任务，任务会安装优先级的顺序执行：</li>
</ul>
<table>
<thead>
<tr>
<th align="center">优先级</th>
<th align="center">任务</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">OUT</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">CLEAR</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">SET</td>
</tr>
</tbody></table>
<h4 id="4-Port-Event-端口事件"><a href="#4-Port-Event-端口事件" class="headerlink" title="4. Port Event (端口事件)"></a>4. Port Event (端口事件)</h4><p>&emsp;&emsp;Port 是一个事件，可以从多个输入引脚使用GPIO检测信号的产生。P0.00~P0.31均可以触发Port事件，Port事件使用了GPIO外设的感知机制，也就是如果使用Port事件，必须操作GPIO外设，在GPIO外设中打开引脚的感知功能，注意Port事件寄存器时属于GPIOTE外设的。<br>&emsp;&emsp;Port不需要任何时钟或者其他电源相关的外设，即使外设处于空闲状态，Port事件也可以使能。当CPU和所有外设处于IDLE状态时，Port是啊金可以将CPU从WFI或WFE类型休眠中，以及CPU空闲模式下唤醒，即在系统ON模式下实现最低的功耗。<br>&emsp;&emsp;Port事件页可以作为唤醒源，将系统从System Off模式唤醒，但本质上还是使用了GPIO外设的感知机制唤醒系统。<br>&emsp;&emsp;配置Port事件时，为了防止Port事件产生虚假的中断，用户应首先禁止Port事件中断，然后再配置Port事件，之后通过清零EVENTS_PORT寄存器清除事件，最后使能Port事件中断。</p>
<h4 id="5-GPIOTE-代码实现"><a href="#5-GPIOTE-代码实现" class="headerlink" title="5. GPIOTE 代码实现"></a>5. GPIOTE 代码实现</h4><h5 id="5-1-Sdk-config-h-配置"><a href="#5-1-Sdk-config-h-配置" class="headerlink" title="5.1   Sdk_config.h 配置"></a>5.1   Sdk_config.h 配置</h5><h6 id="5-1-1-Registers-寄存器版本"><a href="#5-1-1-Registers-寄存器版本" class="headerlink" title="5.1.1   Registers (寄存器版本)"></a>5.1.1   Registers (寄存器版本)</h6><p>  如果配置寄存器版本的话，不许需要在Sdk_config.h文件中配置。</p>
<h6 id="5-1-2-Library-库版本"><a href="#5-1-2-Library-库版本" class="headerlink" title="5.1.2   Library (库版本)"></a>5.1.2   Library (库版本)</h6><ol>
<li><p>添加 GPIOTE 驱动文件 nrfx_gpiote.c ，SDK 路径目录：…\modules\nrfx\drivers\src\nrfx_gpiote.c </p>
</li>
<li><p>头文件引用 “nrf_drv_gpiote.h”。</p>
</li>
<li><p>添加头文件路径:</p>
<ul>
<li><strong>…\modules\nrfx\drivers\include</strong></li>
<li><strong>…\integration\nrfx\legacy</strong></li>
</ul>
</li>
<li><p>Sdk_config.h 文件配置</p>
<ul>
<li><p>Text Editor 配置</p>
<ul>
<li>GPIOTE_ENABLED   <strong>0</strong></li>
<li>GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS   <strong>4</strong></li>
<li>GPIOTE_CONFIG_IRQ_PRIORITY   <strong>1</strong></li>
<li>NRFX_GPIOTE_ENABLED   <strong>1</strong></li>
<li>NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS   <strong>1</strong></li>
<li>NRFX_GPIOTE_CONFIG_IRQ_PRIORITY   <strong>1</strong></li>
<li>NRFX_GPIOTE_CONFIG_LOG_ENABLED   <strong>0</strong></li>
<li>NRFX_GPIOTE_CONFIG_LOG_LEVEL   <strong>3</strong></li>
<li>NRFX_GPIOTE_CONFIG_INFO_COLOR   <strong>0</strong></li>
<li>NRFX_GPIOTE_CONFIG_DEBUG_COLOR   <strong>0</strong></li>
</ul>
</li>
<li><p>Configuration Wizard 配置</p>
<p><img src="/2020/08/06/GPIOTE/GPIOTE.png" alt="GPIOTE"></p>
<p><img src="/2020/08/06/GPIOTE/NRFX_GPIOTE.png" alt></p>
</li>
</ul>
</li>
</ol>
<h5 id="5-2-GPIOTE-Registers-寄存器版本"><a href="#5-2-GPIOTE-Registers-寄存器版本" class="headerlink" title="5.2   GPIOTE Registers (寄存器版本)"></a>5.2   GPIOTE Registers (寄存器版本)</h5><h6 id="5-2-1-gpiote-h-配置"><a href="#5-2-1-gpiote-h-配置" class="headerlink" title="5.2.1  gpiote.h 配置"></a>5.2.1  gpiote.h 配置</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiote.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Created on: 2020-08-06</span></span><br><span class="line"><span class="comment"> *       Author: wuliZhao_ch</span></span><br><span class="line"><span class="comment"> *  Description: GPIOTE Interrupt Configuration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GPIOTE_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOTE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf52.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_gpio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_drv_gpiote.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"app_error.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register versions and library versions select */</span></span><br><span class="line"><span class="comment">// #define REGISTER_VERSION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBRARY_VERSION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*      BUTTON DEFINE      */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_BUTTON1 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_BUTTON2 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_BUTTON3 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_BUTTON4 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*      LED PIN DEFINE    */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_LED1 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_LED2 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_LED3 19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_LED4 20</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//void GPIOTE_IRQHandler(void);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpiote_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GPIOTE_H__ */</span></span></span><br></pre></td></tr></table></figure>

<h6 id="5-2-2-gpiote-c-配置"><a href="#5-2-2-gpiote-c-配置" class="headerlink" title="5.2.2 gpiote.c 配置"></a>5.2.2 gpiote.c 配置</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiote.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Created on: 2020-08-06</span></span><br><span class="line"><span class="comment"> *       Author: wuliZhao_ch</span></span><br><span class="line"><span class="comment"> *  Description: GPIOTE Interrupt Configuration</span></span><br><span class="line"><span class="comment">                 Register versions and library function versions implement GPIOTE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gpiote.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpiote_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    nrf_gpio_cfg_input(PCA10040_BUTTON1, NRF_GPIO_PIN_PULLUP);</span><br><span class="line">    nrf_gpio_cfg_input(PCA10040_BUTTON2, NRF_GPIO_PIN_PULLUP);</span><br><span class="line">    nrf_gpio_cfg_input(PCA10040_BUTTON3, NRF_GPIO_PIN_PULLUP);</span><br><span class="line">    nrf_gpio_cfg_input(PCA10040_BUTTON4, NRF_GPIO_PIN_PULLUP);</span><br><span class="line"></span><br><span class="line">    NVIC_EnableIRQ(GPIOTE_IRQn);        <span class="comment">/* Enable Interrupt */</span></span><br><span class="line"></span><br><span class="line">    NRF_GPIOTE-&gt;CONFIG[<span class="number">0</span>] = (GPIOTE_CONFIG_MODE_Event &lt;&lt; GPIOTE_CONFIG_MODE_Pos) | (PCA10040_BUTTON1 &lt;&lt; GPIOTE_CONFIG_PSEL_Pos) |(GPIOTE_CONFIG_POLARITY_HiToLo &lt;&lt; GPIOTE_CONFIG_POLARITY_Pos);</span><br><span class="line">    NRF_GPIOTE-&gt;CONFIG[<span class="number">1</span>] = (GPIOTE_CONFIG_MODE_Event &lt;&lt; GPIOTE_CONFIG_MODE_Pos) | (PCA10040_BUTTON2 &lt;&lt; GPIOTE_CONFIG_PSEL_Pos) |(GPIOTE_CONFIG_POLARITY_HiToLo &lt;&lt; GPIOTE_CONFIG_POLARITY_Pos);</span><br><span class="line">    NRF_GPIOTE-&gt;CONFIG[<span class="number">2</span>] = (GPIOTE_CONFIG_MODE_Event &lt;&lt; GPIOTE_CONFIG_MODE_Pos) | (PCA10040_BUTTON3 &lt;&lt; GPIOTE_CONFIG_PSEL_Pos) |(GPIOTE_CONFIG_POLARITY_HiToLo &lt;&lt; GPIOTE_CONFIG_POLARITY_Pos);</span><br><span class="line">    NRF_GPIOTE-&gt;CONFIG[<span class="number">3</span>] = (GPIOTE_CONFIG_MODE_Event &lt;&lt; GPIOTE_CONFIG_MODE_Pos) | (PCA10040_BUTTON4 &lt;&lt; GPIOTE_CONFIG_PSEL_Pos) |(GPIOTE_CONFIG_POLARITY_HiToLo &lt;&lt; GPIOTE_CONFIG_POLARITY_Pos);</span><br><span class="line"></span><br><span class="line">    NRF_GPIOTE-&gt;INTENSET = GPIOTE_INTENSET_IN0_Set &lt;&lt; GPIOTE_INTENSET_IN0_Pos;</span><br><span class="line">    NRF_GPIOTE-&gt;INTENSET = GPIOTE_INTENSET_IN1_Set &lt;&lt; GPIOTE_INTENSET_IN1_Pos;</span><br><span class="line">    NRF_GPIOTE-&gt;INTENSET = GPIOTE_INTENSET_IN2_Set &lt;&lt; GPIOTE_INTENSET_IN2_Pos;</span><br><span class="line">    NRF_GPIOTE-&gt;INTENSET = GPIOTE_INTENSET_IN3_Set &lt;&lt; GPIOTE_INTENSET_IN3_Pos;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIOTE_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nrf_gpio_pin_read(PCA10040_BUTTON1)== <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((NRF_GPIOTE-&gt;EVENTS_IN[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (NRF_GPIOTE-&gt;INTENSET &amp; GPIOTE_INTENSET_IN0_Msk))</span><br><span class="line">        &#123;</span><br><span class="line">            NRF_GPIOTE-&gt;EVENTS_IN[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//中断事件清零.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nrf_gpio_pin_read(PCA10040_BUTTON1)== <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nrf_gpio_pin_toggle(PCA10040_LED1);<span class="comment">//led灯翻转</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nrf_gpio_pin_read(PCA10040_BUTTON2)== <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((NRF_GPIOTE-&gt;EVENTS_IN[<span class="number">1</span>] == <span class="number">1</span>) &amp;&amp; (NRF_GPIOTE-&gt;INTENSET &amp; GPIOTE_INTENSET_IN1_Msk))</span><br><span class="line">        &#123;</span><br><span class="line">            NRF_GPIOTE-&gt;EVENTS_IN[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//中断事件清零.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nrf_gpio_pin_read(PCA10040_BUTTON2)== <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nrf_gpio_pin_toggle(PCA10040_LED2);<span class="comment">//led灯翻转</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nrf_gpio_pin_read(PCA10040_BUTTON3)== <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((NRF_GPIOTE-&gt;EVENTS_IN[<span class="number">2</span>] == <span class="number">1</span>) &amp;&amp; (NRF_GPIOTE-&gt;INTENSET &amp; GPIOTE_INTENSET_IN2_Msk))</span><br><span class="line">        &#123;</span><br><span class="line">            NRF_GPIOTE-&gt;EVENTS_IN[<span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 中断事件清零.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nrf_gpio_pin_read(PCA10040_BUTTON3)== <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nrf_gpio_pin_toggle(PCA10040_LED3);<span class="comment">// LED灯翻转</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(nrf_gpio_pin_read(PCA10040_BUTTON4)== <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((NRF_GPIOTE-&gt;EVENTS_IN[<span class="number">3</span>] == <span class="number">1</span>) &amp;&amp; (NRF_GPIOTE-&gt;INTENSET &amp; GPIOTE_INTENSET_IN3_Msk))</span><br><span class="line">        &#123;</span><br><span class="line">            NRF_GPIOTE-&gt;EVENTS_IN[<span class="number">3</span>] = <span class="number">0</span>; <span class="comment">//中断事件清零.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(nrf_gpio_pin_read(PCA10040_BUTTON4)== <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nrf_gpio_pin_toggle(PCA10040_LED4);<span class="comment">//LED灯翻转</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-GPIOTE-Library-库版本"><a href="#5-3-GPIOTE-Library-库版本" class="headerlink" title="5.3   GPIOTE Library (库版本)"></a>5.3   GPIOTE Library (库版本)</h5><h6 id="5-3-1-gpiote-h-配置"><a href="#5-3-1-gpiote-h-配置" class="headerlink" title="5.3.1 gpiote.h 配置"></a>5.3.1 gpiote.h 配置</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiote.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Created on: 2020-08-06</span></span><br><span class="line"><span class="comment"> *       Author: wuliZhao_ch</span></span><br><span class="line"><span class="comment"> *  Description: GPIOTE Interrupt Configuration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GPIOTE_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPIOTE_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf52.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_gpio.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_drv_gpiote.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"app_error.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Register versions and library versions select */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REGISTER_VERSION</span></span><br><span class="line"><span class="comment">//#define LIBRARY_VERSION</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*      BUTTON DEFINE      */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_BUTTON1 13</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_BUTTON2 14</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_BUTTON3 15</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_BUTTON4 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*      LED PIN DEFINE    */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_LED1 17</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_LED2 18</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_LED3 19</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCA10040_LED4 20</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GPIOTE_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpiote_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* GPIOTE_H__ */</span></span></span><br></pre></td></tr></table></figure>

<h6 id="5-3-2-gpiote-c配置"><a href="#5-3-2-gpiote-c配置" class="headerlink" title="5.3.2 gpiote.c配置"></a>5.3.2 gpiote.c配置</h6><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gpiote.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Created on: 2020-08-06</span></span><br><span class="line"><span class="comment"> *       Author: wuliZhao_ch</span></span><br><span class="line"><span class="comment"> *  Description: GPIOTE Interrupt Configuration</span></span><br><span class="line"><span class="comment">                 Register versions and library function versions implement GPIOTE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_gpiote_handler</span><span class="params">(<span class="keyword">nrf_drv_gpiote_pin_t</span> pin, <span class="keyword">nrf_gpiote_polarity_t</span> action)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (pin)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> PCA10040_BUTTON1:</span><br><span class="line">            nrf_gpio_pin_toggle(PCA10040_LED1);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PCA10040_BUTTON2:</span><br><span class="line">            nrf_gpio_pin_toggle(PCA10040_LED2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PCA10040_BUTTON3:</span><br><span class="line">            nrf_gpio_pin_toggle(PCA10040_LED3);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PCA10040_BUTTON4:</span><br><span class="line">            nrf_gpio_pin_toggle(PCA10040_LED4);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpiote_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">ret_code_t</span> err_code;</span><br><span class="line"></span><br><span class="line">    err_code = nrf_drv_gpiote_init();</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nrf_drv_gpiote_in_config_t</span> in_config = GPIOTE_CONFIG_IN_SENSE_HITOLO(<span class="literal">true</span>);</span><br><span class="line">    in_config.pull = NRF_GPIO_PIN_PULLUP;</span><br><span class="line"></span><br><span class="line">    err_code = nrf_drv_gpiote_in_init(PCA10040_BUTTON1, &amp;in_config, in_gpiote_handler);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">    err_code = nrf_drv_gpiote_in_init(PCA10040_BUTTON2, &amp;in_config, in_gpiote_handler);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">    err_code = nrf_drv_gpiote_in_init(PCA10040_BUTTON3, &amp;in_config, in_gpiote_handler);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line">    err_code = nrf_drv_gpiote_in_init(PCA10040_BUTTON4, &amp;in_config, in_gpiote_handler);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line"></span><br><span class="line">    nrf_drv_gpiote_in_event_enable(PCA10040_BUTTON1, <span class="literal">true</span>);</span><br><span class="line">    nrf_drv_gpiote_in_event_enable(PCA10040_BUTTON2, <span class="literal">true</span>);</span><br><span class="line">    nrf_drv_gpiote_in_event_enable(PCA10040_BUTTON3, <span class="literal">true</span>);</span><br><span class="line">    nrf_drv_gpiote_in_event_enable(PCA10040_BUTTON4, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-MAIN-C-调用实现"><a href="#5-4-MAIN-C-调用实现" class="headerlink" title="5.4 MAIN.C 调用实现"></a>5.4 MAIN.C 调用实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nordic_common.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"boards.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_delay.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_drv_systick.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_drv_clock.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_drv_timer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_log.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_log_ctrl.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_log_default_backends.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_pwr_mgmt.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* wuliZhaoch Include File */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"timer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"gpiote.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Function for application main entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    gpiote_init();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (NRF_LOG_PROCESS() == <span class="literal">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nrf_pwr_mgmt_run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** @&#125; */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nordic</category>
      </categories>
      <tags>
        <tag>Nordic</tag>
        <tag>Bluetooth</tag>
        <tag>nRF52</tag>
      </tags>
  </entry>
  <entry>
    <title>【Git】学习笔记 --&gt; Git 初次运行前的配置</title>
    <url>/2020/05/07/Git%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<h2 id="Git初次运行配置"><a href="#Git初次运行配置" class="headerlink" title="Git初次运行配置"></a>Git初次运行配置</h2><h3 id="1-用户信息"><a href="#1-用户信息" class="headerlink" title="1.    用户信息"></a>1.    用户信息</h3><ul>
<li>安装完Git应该做的第一件事就是设置自己的用户名称和邮件地址.</li>
<li>命令如下:<ul>
<li><code>$ git config --global user.name &quot;Zhao_ch&quot;</code> </li>
<li><code>$ git config --global user.email &quot;Zhao_ch@163.com&quot;</code></li>
</ul>
</li>
<li>如果使用了–global选项，那么该命令是需要运行一次，因为之后无论你在系统上做任何事情，Git都会使用这些信息  </li>
</ul>
<h3 id="2-文本编辑器"><a href="#2-文本编辑器" class="headerlink" title="2.   文本编辑器"></a>2.   文本编辑器</h3><ul>
<li>用户信息设置完毕，可以设置默认文本编辑器  </li>
<li>如果没有设置，Git会使用操作系统默认的文本编辑器，通常是Vim </li>
<li>例如设置文本编辑器为Notepad++  <ul>
<li>命令如下：    <ul>
<li>`$ git config –global core.editor Notepad++</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-检查配置信息"><a href="#3-检查配置信息" class="headerlink" title="3.   检查配置信息"></a>3.   检查配置信息</h3><ul>
<li>如果查询配置信息可以使用 $ git config –list 命令列出所有配置信息。</li>
</ul>
<h3 id="4-生成密钥"><a href="#4-生成密钥" class="headerlink" title="4.   生成密钥"></a>4.   生成密钥</h3><ul>
<li>命令如下:<ul>
<li><code>$ ssh-keygen -t rsa -C &quot;Zhao_ch@163.com&quot;</code></li>
</ul>
</li>
<li>如果不设置密码的话 连续 3 个回车。然后生成 id_rsa 和 id_rsa.pub 两个文件。<ul>
<li><strong>Hosts文件配置 文件位置</strong> <strong>C:\Windows\System32\drivers\etc\hosts</strong>     </li>
<li>添加 35.231.145.151 <a href="http://gitlab.com/" target="_blank" rel="noopener">gitlab.com</a>   </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Gitlab</tag>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>【Git】学习笔记 --&gt; Git 分支管理 (Git_Flow)</title>
    <url>/2020/05/08/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-Git-Flow/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<ul>
<li><p>主分支Master：</p>
<pre><code>代码库应该有一个，且仅有一个主分支。(提供给用户的正式版本，都在主分支上发布(有版本标签))</code></pre></li>
<li><p>开发分支Develop：</p>
<pre><code>主分支只用来发布重大版本，日常开发应该在另一条分支(即开发分支（Develop))
Git创建Develop分支命令：
    git checkout -b develop master
Develop分支合并到Master分支命令：
# 切换到Master分支：
    git checkout master
# 对Develop分支进行合并
    git merge --no-ff develop
（--no-ff参数：默认情况下，Git执行&quot;快进式合并&quot; Fast-Farward merge 直接将Master分支指向Develop分支）</code></pre></li>
<li><p>临时性分支：</p>
<pre><code>Master 和 Develop，前者用于正式发布，后者用于日常开发。除了常设分支以外，还有一些临时分支，用于应用一些特定目的的版本开发。临时性分支有三种：
    功能（feature）分支
    预发布（release）分支
    修补bug（fixbug）分支
（这三种分支属于临时性需要，使用完成之后，应该删除，使得代码库的常设分支始终只有Master和Develop分支）

1. 功能分支：
    功能分支，是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要合并到Develop分支上。(功能分支的名字，可以采用feature-*的形式命名)
    Git 创建一个功能分支：
        git checkout -b feature-x develop
    开发完成后，将功能分支合并到develop分支：
        git checkout develop
        git merge --no-ff feature-x
    删除featur-x分支：
        git branch -d feature-x

2. 预发布分支：
    指发布正式版本之前（即合并Master分支之前），可能需要有一个预发布的版本进行测试。
    预发布分支是从Develop分支上边分出来的，预发布结束后，必须合并进Develop和Master分支上。
    命名采用release-*的形式：
    创建一个预发布分支：
    git checkout -b release-1.2 develop
确认没有问题后，合并Master分支：
    git checkout master
    git merge --no-ff release-1.2
    # 对合并生成的新节点，做一个标签
    git tag -a 1.2
然后合并到develop分支：
    git checkout develop
    git merge --no-ff release-1.2
最后删除预发布分支：
    git branch -d release-1.2

3. 修补bug分支：
        软件正式发布以后，难免回出现bug。这是就需要创建一个分支，进行bug修补.
        修补bug分支是从Master分支上面分出来的。修补结束后，再合并进Master和Develop分支。
    命名采用fixbug-*的形式:
        创建一个修补bug分支：
            git checkout -b fixbug-0.1 master
        修补结束后，合并到master分支：
            git checkout master
            git merge --no-ff fixbug-0.1
            git tag -a 0.1.1
        再合并到develop分支：
            git checkout develop
            git merge --no-ff fixbug-0.1
    最后，删除&quot;修补bug分支&quot;：
        git branch -d fixbug-0.1</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Gitlab</tag>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>【nRF52832】学习笔记 --&gt; Flash Data Storage (FDS)存储</title>
    <url>/2020/07/11/Nordic-FDS/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<p>环境介绍</p>
<ul>
<li>操作系统:   Window10 企业版</li>
<li>IDE开发环境:   ARM_MDK5 (Keil5)</li>
<li>SDK版本:   SDK_17.0.0 </li>
<li>硬件开发板:   官方开发板 PCA10040</li>
</ul>
<a id="more"></a>

<h2 id="Flash-Data-Storage-FDS-存储"><a href="#Flash-Data-Storage-FDS-存储" class="headerlink" title="Flash Data Storage (FDS)存储"></a>Flash Data Storage (FDS)存储</h2><h4 id="1-FDS概述介绍"><a href="#1-FDS概述介绍" class="headerlink" title="1.  FDS概述介绍"></a>1.  FDS概述介绍</h4><p>&emsp;&emsp;FDS (<em>Flash Data Storage</em>) 模块是用于芯片上闪存存储的一个最小文件系统，可以最大限度地降低数据损坏的风险，并简化与持久存储的交互。Nordic芯片内部FLASH的存储官方提供了两种方式，一种是 FS (<em>Flash Storage</em>)、另一种是FDS (<em>Flash Data Storage</em>) 。相对于FS (<em>Flash Storage</em>)来说，FDS (<em>Flash Data Storage</em>)对数据的组织性和安全性更强。</p>
<p>FDS模块的设计也提供了以下优点:</p>
<ul>
<li><p>通过不断验证最小化访问损坏数据的风险: </p>
<ul>
<li>在断电的情况下，数据可能写入不完整。验证确保FDS能够识别无效数据，并且不会将损坏的数据返回给用户。</li>
</ul>
</li>
<li><p>在打开记录时提供(可选的)CRC验证，以确保数据自写入以后没有改变。</p>
</li>
<li><p>最小化Flash操作(更新和删除):</p>
<ul>
<li>FDS不是删除整个页面，而是存储新数据的副本，并通过一个字写入来使过时的数据失效。</li>
</ul>
</li>
<li><p>基本损耗均衡:</p>
<ul>
<li>Flash的使用寿命是有限的，Flash具有最大可擦写次数，一旦对Flash的某个块的擦写超过最大擦写次数，这个块就会损坏。所以对Flash的擦写应该均匀的分布在快上，将块充分利用，减少擦写的次数，提高Flash的使用寿命。</li>
</ul>
</li>
<li><p>不需要复制数据就可以轻松访问数据，这使得访问数据的影响与数据大小无关。</p>
</li>
<li><p>通过灵活选择数据块的大小来最小化的使用内存。</p>
</li>
<li><p>对数据的内容不加限制 (这意味着它可以包含特殊字符) 。</p>
<p><strong>Flash数据存储支持同步读取操作和异步写入。</strong></p>
</li>
</ul>
<h4 id="2-FDS功能介绍"><a href="#2-FDS功能介绍" class="headerlink" title="2.  FDS功能介绍"></a>2.  FDS功能介绍</h4><p>&emsp;&emsp;Flash Data Storage API 公开了操作文件和记录的功能，文件由一条或多条包含实际数据的记录组成，每一条记录都由一个 <strong>KEY</strong> 标志并通过 <strong>File ID</strong> 关联到文件。File ID 和 Record Key 都不要求必须是唯一的，并且文件可以包含具有相同 Key 的多个记录，可以通过 File ID 和 Record Key 的任意组合访问记录。</p>
<p>For Example，an application could use the following two files:</p>
<ul>
<li><p>File 1 with two record:     0x1111 = “Phone1”,  0x2222 = “data:123456”</p>
</li>
<li><p>File 2 with three record:  0x1111 = “Tables1”,  0x2222 = “data:123456”,  0x2222 = “data: adcsdf”</p>
</li>
</ul>
<p>&emsp;&emsp;可以遍历File 1中的所有记录，所有Key为0x2222的记录。可以遍历File 2 中 Key 为0x1111 的记录。</p>
<h5 id="2-1-Creating-Record-创建记录"><a href="#2-1-Creating-Record-创建记录" class="headerlink" title="2.1   Creating Record (创建记录)"></a>2.1   Creating Record (创建记录)</h5><ul>
<li>新记录写入Flash时，必须提供Record Key、File ID 和 将要写入的数据。</li>
<li>更新记录 (写记录)成功后，返回一个记录描述符，可以用它来访问记录。在访问之前，等待表明写入操作成功完成的事件。</li>
</ul>
<h5 id="2-2-Manipulating-Record-处理记录"><a href="#2-2-Manipulating-Record-处理记录" class="headerlink" title="2.2   Manipulating Record (处理记录)"></a>2.2   Manipulating Record (处理记录)</h5><ul>
<li>读取、更新或者删除记录的内容，必须通过记录的描述符访问记录。首次记录写入Flash时，FDS会创建并返回一个此记录的描述符。</li>
<li>获取记录描述符函数：<ul>
<li>fds_record_find</li>
<li>fds_record_find_by_key</li>
<li>fds_record_find_in_file</li>
</ul>
</li>
<li>以上函数可以根据 Record key 和 File ID 查找记录。 </li>
<li>FDS 并没有要求 Record Key 或 File ID 是唯一的。因此，在查找记录的时候可能会找到多个匹配的记录。记路查找函数每次返回一个匹配的记录并保存当前查找的进度，返回的 Token 记录了最新匹配的记录位置，通过 Token 在接下来的查找中就可以不必从头开始，直接从 Token 记录的位置开始即可。</li>
</ul>
<h5 id="2-3-Reading-Record-读取记录"><a href="#2-3-Reading-Record-读取记录" class="headerlink" title="2.3   Reading Record (读取记录)"></a>2.3   Reading Record (读取记录)</h5><ul>
<li>读取记录可以直接在Flash中读取内容 (存储数据和元数据)，这意味着应用程序将决定时复制数据，将数据存储在 RAM 中还是在本地使用数据。</li>
<li>访问记录内容 (读取数据)，需要打开记录以检索指向记录数据和元数据存储在Flash中的位置的指针。使用 <strong>fds_record_open()</strong> 函数打开记录，<strong>fds_record_open()</strong> 函数确保在访问记录时不会修改记录或记录移动到 Flash 中的其他位置。访问记录完成后，必须关闭记录 <strong>fds_record_close()</strong> 以释放对记录的锁定。</li>
</ul>
<h5 id="2-4-Updating-Record-更新记录"><a href="#2-4-Updating-Record-更新记录" class="headerlink" title="2.4   Updating Record (更新记录)"></a>2.4   Updating Record (更新记录)</h5><ul>
<li>FDS 更新记录，即所谓的写数据。FDS 并不是将新数据写到原来的记录中去覆盖旧数据，而是创建一个新记录，然后将原有的记录作废，更新记录时，记录更新函数会返回一个新的记录描述符。</li>
<li>FDS 更新记录的方式是作废旧记录，创建新记录，更新记录频繁的话，每次都会创建新的记录，这样的话会占用Flash的空间，所以通过碎片整理收集功能来释放Flash。</li>
</ul>
<h5 id="2-5-Deleting-Record-删除记录"><a href="#2-5-Deleting-Record-删除记录" class="headerlink" title="2.5   Deleting Record (删除记录)"></a>2.5   Deleting Record (删除记录)</h5><ul>
<li>记录删除并不是真正的删除记录数据和擦除Flash空间，而是通过设置标志将需要删除的记录作废。每一条被删除的记录，就不能再对它进行打开、读、定位等相关的操作。</li>
<li>记录删除后，记录所使用的Flash空间不会立即释放，如果想要释放Flash空间，必须通过碎片收集来实现。</li>
</ul>
<h5 id="2-6-Garbage-collection-垃圾收集"><a href="#2-6-Garbage-collection-垃圾收集" class="headerlink" title="2.6   Garbage collection (垃圾收集)"></a>2.6   Garbage collection (垃圾收集)</h5><ul>
<li>不管是更新数据还是擦除数据，都会产生无效数据，这些数据都是实际存在的，占用Flash空间，因此可以调用 <strong>fds_gc()</strong> 函数API进行垃圾回收。通过执行此操作来释放这些占用Flash的无效数据。</li>
<li>垃圾收集不会自动通过FDS收集。理想情况下，应该在Ble处于低功耗的情况下进行垃圾收集，长期更新记录，产生的无效数据会将内存占满，再一次请求数据更新时，会直接返回 FDS_ERR_NO_SPACE_IN_FLASH (Flash 无空间) 错误，然后必须进行垃圾回收并等待完成后，再更新数据。</li>
</ul>
<h5 id="2-7-Restrictions-on-keys-and-IDs-FDS对-KEY-和-File-ID-的限制"><a href="#2-7-Restrictions-on-keys-and-IDs-FDS对-KEY-和-File-ID-的限制" class="headerlink" title="2.7   Restrictions on keys and IDs (FDS对 KEY 和 File ID 的限制)"></a>2.7   Restrictions on keys and IDs (FDS对 KEY 和 File ID 的限制)</h5><ul>
<li><p>Record Key 应在 0x0001 - 0xBFFF 范围内，0x0000 值是由系统保留。从 0xC000 到 0xFFFF 的值保留供Peer Manager模块使用，并且只能在不包含 Peer Manager 的应用程序中使用。</p>
</li>
<li><p>File ID 的应在0x0000 - 0xBFFF 范围内, 0xFFFF 是被系统使用的，从 0xC000 到 0xFFFE 的值保留供Peer Manager模块使用，并且只能在不包含 Peer Manager 的应用程序中使用</p>
</li>
</ul>
<h4 id="3-SDK-Config-FDS配置宏介绍"><a href="#3-SDK-Config-FDS配置宏介绍" class="headerlink" title="3.  SDK_Config  FDS配置宏介绍"></a>3.  SDK_Config  FDS配置宏介绍</h4><h5 id="3-1-FDS-VIRTUAL-PAGES"><a href="#3-1-FDS-VIRTUAL-PAGES" class="headerlink" title="3.1   FDS_VIRTUAL_PAGES"></a>3.1   FDS_VIRTUAL_PAGES</h5><ul>
<li>配置使用虚拟页的数量及其大小。</li>
<li>使用的 Flash Memory 总量取决于虚拟页的大小和数量。</li>
</ul>
<h5 id="3-2-FDS-VIRTUAL-PAGE-SIZE"><a href="#3-2-FDS-VIRTUAL-PAGE-SIZE" class="headerlink" title="3.2   FDS_VIRTUAL_PAGE_SIZE"></a>3.2   FDS_VIRTUAL_PAGE_SIZE</h5><ul>
<li>虚拟页的大小。</li>
<li>默认情况下，虚拟页与物理页大小相同。</li>
<li>虚拟页的大小必须是物理页大小的倍数。</li>
<li>已字为单位 (4-Byte)。</li>
</ul>
<h5 id="3-3-FDS-VIRTUAL-PAGES-RESERVED"><a href="#3-3-FDS-VIRTUAL-PAGES-RESERVED" class="headerlink" title="3.3   FDS_VIRTUAL_PAGES_RESERVED"></a>3.3   FDS_VIRTUAL_PAGES_RESERVED</h5><ul>
<li>其他模块使用的虚拟FLASH页数。</li>
<li>FDS模块将其数据存储在FLASH的最后一页中，通过设置此值，可以移动FDS使用的FLASH结束地地址。保留的空间可以被其他模块使用。</li>
</ul>
<h5 id="3-4-FDS-OP-QUEUE-SIZE"><a href="#3-4-FDS-OP-QUEUE-SIZE" class="headerlink" title="3.4   FDS_OP_QUEUE_SIZE"></a>3.4   FDS_OP_QUEUE_SIZE</h5><ul>
<li>FDS 程序模块内部使用的队列大小，如果FDS用户较多或者应用程序中希望一次排队更多的操作而不等待先前的操作完成，可加大队列的大小。</li>
<li>一般情况下，如果应用程序中经常接受到错误代码 FDS_ERR_NO_SPACE_IN_QUEUES,则需要增加队列大小。</li>
</ul>
<h5 id="3-5-FDS-CRC-CHECK-ON-READ"><a href="#3-5-FDS-CRC-CHECK-ON-READ" class="headerlink" title="3.5   FDS_CRC_CHECK_ON_READ"></a>3.5   FDS_CRC_CHECK_ON_READ</h5><ul>
<li>如果使能该配置项，FDS 将会启动读取操作的CRC检查 (fds_record_open)。</li>
</ul>
<h5 id="3-6-FDS-CRC-CHECK-ON-WRITE"><a href="#3-6-FDS-CRC-CHECK-ON-WRITE" class="headerlink" title="3.6   FDS_CRC_CHECK_ON_WRITE"></a>3.6   FDS_CRC_CHECK_ON_WRITE</h5><ul>
<li>可选的配置项，如果使能，FDS 写操作会进行校验。</li>
<li>使能该配置时，FDS_CRC_CHECK_ON_READ 必须打开。</li>
</ul>
<h5 id="3-7-FDS-MAX-USERS"><a href="#3-7-FDS-MAX-USERS" class="headerlink" title="3.7   FDS_MAX_USERS"></a>3.7   FDS_MAX_USERS</h5><ul>
<li>可以注册的最大回调数。</li>
<li>如果收到 FDS_ERR_USER_LIMIT_REACHED 错误，请增加此数值。</li>
</ul>
<h4 id="4-Storage-format-存储格式"><a href="#4-Storage-format-存储格式" class="headerlink" title="4.  Storage format (存储格式)"></a>4.  Storage format (存储格式)</h4><p>&emsp;&emsp;FDS 以记录的方式将数据存储到 Flash 中，这些记录被分组到文件中，在大多数用例中我们无需详细了解 FDS 如何将数据存储在 Flash 中。以下是FDS使用的数据格式相关信息，如果你对 FDS 详细信息不感兴趣，可以跳过。</p>
<h5 id="4-1-Record-layout-记录布局"><a href="#4-1-Record-layout-记录布局" class="headerlink" title="4.1   Record layout (记录布局)"></a>4.1   Record layout (记录布局)</h5><p>&emsp;&emsp;Record 由 Record Header (Record 元数据) 和实际内容组成，Record Header 用来标记Record，记录内容是实际存储的数据，它们按照如图所示的顺序连续存储在 Flash 中。</p>
<p><img src="/2020/07/11/Nordic-FDS/00_Layout_of_a_record.png" alt="Layout of a record"></p>
<h5 id="4-2-Record-header-记录头"><a href="#4-2-Record-header-记录头" class="headerlink" title="4.2   Record header (记录头)"></a>4.2   Record header (记录头)</h5><p>&emsp;&emsp;Record header 由 3个字 (12个Byte) 组成，各部分描述如下:</p>
<p><img src="/2020/07/11/Nordic-FDS/01_Record_header.png" alt="Record header"></p>
<p>&emsp;&emsp;FDS 将 Record Header 写入 Flash 中，首先写入Record Key 和数据长度，接着写入Record ID，最后写入 File ID 和 CRC 校验值，并完成成功的写入操作。检索Record的时候，FDS会忽略掉所有Record Header中第二个字美音写入的 Record，因为缺少Key意味着这条Record没有写入完整。</p>
<h5 id="4-3-Maximum-length-最大存储数据长度"><a href="#4-3-Maximum-length-最大存储数据长度" class="headerlink" title="4.3   Maximum length (最大存储数据长度)"></a>4.3   Maximum length (最大存储数据长度)</h5><p>Record 的最大长度取决于三个值:</p>
<ul>
<li>虚拟 Flash 页的大小 (FDS_VIRTUAL_PAGE_SIZE)</li>
<li>页面标记大小 (2 Words)</li>
<li>Record Header的大小 (3 Words)</li>
</ul>
<p>sdk_config.h 中默认的设置是虚拟 Flash 页的大小和物理页大小一样  (对于nRF52832来说是1024个字，即4096个字节)，对于默认值来说去掉页面标记和记录头后，最大数据长度是1019个字。</p>
<h5 id="4-4-Page-tag-页面标签"><a href="#4-4-Page-tag-页面标签" class="headerlink" title="4.4   Page tag (页面标签)"></a>4.4   Page tag (页面标签)</h5><p>&emsp;&emsp;FDS 使用的每个虚拟页面都标有一个页面标记，系统使用该标记来存储有关该页面的信息。两个字长的页面标签包含了页面用途 ( 数据存储或垃圾收集)以及页面上安装的文件系统版本的信息。</p>
<p><img src="/2020/07/11/Nordic-FDS/02_Page_tags.png" alt="Page_tags"></p>
<h4 id="5-FDS-使用方法"><a href="#5-FDS-使用方法" class="headerlink" title="5.  FDS 使用方法"></a>5.  FDS 使用方法</h4><h5 id="5-1-Initializing-the-module-初始化FDS"><a href="#5-1-Initializing-the-module-初始化FDS" class="headerlink" title="5.1   Initializing the module (初始化FDS)"></a>5.1   Initializing the module (初始化FDS)</h5><p>&emsp;&emsp;Before initializing FDS, you must initialize the SoftDevice and register a callback handler to handle FDS events. (初始化FDS之前，必须初始化SoftDevice并注册回调函数来处理FDS事件。)</p>
<p>&emsp;&emsp;以下代码区展示了如何注册FDS事件的处理函数以及如何初始化 FDS 模块:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Simple event handler to handle errors during initialization. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fds_evt_handler</span><span class="params">(<span class="keyword">fds_evt_t</span> <span class="keyword">const</span> * p_fds_evt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (p_fds_evt-&gt;id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> FDS_EVT_INIT:</span><br><span class="line">            <span class="keyword">if</span> (p_fds_evt-&gt;result != NRF_SUCCESS)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Initialization failed. */</span> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ret_code_t</span> ret = fds_register(fds_evt_handler);</span><br><span class="line"><span class="keyword">if</span> (ret != NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Registering of the FDS event handler has failed. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ret_code_t</span> ret = fds_init();</span><br><span class="line"><span class="keyword">if</span> (ret != NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle error. */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-Writing-a-record"><a href="#5-2-Writing-a-record" class="headerlink" title="5.2   Writing a record"></a>5.2   Writing a record</h5><p>&emsp;&emsp;以下代码区展示了如何写记录:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_ID         0x0001  <span class="comment">/* The ID of the file to write the records into. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECORD_KEY_1    0x1111  <span class="comment">/* A key for the first record. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECORD_KEY_2    0x2222  <span class="comment">/* A key for the second record. */</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span>   <span class="keyword">const</span> m_deadbeef = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>       <span class="keyword">const</span> m_hello[]  = <span class="string">"Hello, world!"</span>;</span><br><span class="line"><span class="keyword">fds_record_t</span>        record;</span><br><span class="line"><span class="keyword">fds_record_desc_t</span>   record_desc;</span><br><span class="line"><span class="comment">// Set up record.</span></span><br><span class="line">record.file_id           = FILE_ID;</span><br><span class="line">record.key               = RECORD_KEY_1;</span><br><span class="line">record.data.p_data       = &amp;m_deadbeef;</span><br><span class="line">record.data.length_words = <span class="number">1</span>;   <span class="comment">/* one word is four bytes. */</span></span><br><span class="line"><span class="keyword">ret_code_t</span> rc;</span><br><span class="line">rc = fds_record_write(&amp;record_desc, &amp;record);</span><br><span class="line"><span class="keyword">if</span> (rc != NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle error. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set up record.</span></span><br><span class="line">record.file_id           = FILE_ID;</span><br><span class="line">record.key               = RECORD_KEY_2;</span><br><span class="line">record.data.p_data       = &amp;m_hello;</span><br><span class="line"><span class="comment">/* The following calculation takes into account any eventual remainder of the division. */</span></span><br><span class="line">record.data.length_words = (<span class="keyword">sizeof</span>(m_hello) + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">rc = fds_record_write(&amp;record_desc, &amp;record);</span><br><span class="line"><span class="keyword">if</span> (rc != NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle error. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此命令已存入队列中，并通过时间回调指示成功或失败，如果成功。fds_record_write函数将返回记录的描述符，该描述符可哦用于进一步操作记录。</p>
<h5 id="5-3-Retrieving-data"><a href="#5-3-Retrieving-data" class="headerlink" title="5.3   Retrieving data"></a>5.3   Retrieving data</h5><p>&emsp;&emsp;以下实例显示了如何查找Record功能来检索Record Key 和 File ID 匹配的所记录的记录描述符，并读取它们的数据内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_ID     0x1111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECORD_KEY  0x2222</span></span><br><span class="line"><span class="keyword">fds_flash_record_t</span>  flash_record;</span><br><span class="line"><span class="keyword">fds_record_desc_t</span>   record_desc;</span><br><span class="line"><span class="keyword">fds_find_token_t</span>    ftok;</span><br><span class="line"><span class="comment">/* It is required to zero the token before first use. */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ftok, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(<span class="keyword">fds_find_token_t</span>));</span><br><span class="line"><span class="comment">/* Loop until all records with the given key and file ID have been found. */</span></span><br><span class="line"><span class="keyword">while</span> (fds_record_find(FILE_ID, RECORD_KEY, &amp;record_desc, &amp;ftok) == NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fds_record_open(&amp;record_desc, &amp;flash_record) != NRF_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Handle error. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Access the record through the flash_record structure. */</span></span><br><span class="line">    <span class="comment">/* Close the record when done. */</span></span><br><span class="line">    <span class="keyword">if</span> (fds_record_close(&amp;record_desc) != NRF_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Handle error. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-Deleting-a-record"><a href="#5-4-Deleting-a-record" class="headerlink" title="5.4   Deleting a record"></a>5.4   Deleting a record</h5><p>&emsp;&emsp;以下实例显示了如何删除记录：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Assume a descriptor returned by a call to fds_record_write() or fds_record_find(),</span></span><br><span class="line"><span class="comment">   as shown in the previous example. */</span></span><br><span class="line"><span class="keyword">fds_record_desc_t</span> descriptor;</span><br><span class="line"><span class="keyword">ret_code_t</span> ret = fds_record_delete(&amp;descriptor);</span><br><span class="line"><span class="keyword">if</span> (ret != NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Error. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;调fds_record_delete不会释放此记录使用的 Flash ，要回收删除记录使用的闪存空间，才能释放此记录的Flash，碎片收集运行 fds_gc()。</p>
]]></content>
      <categories>
        <category>Nordic</category>
      </categories>
      <tags>
        <tag>Nordic</tag>
        <tag>Bluetooth</tag>
        <tag>nRF52</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/2020/05/03/Personal_Blog/</url>
    <content><![CDATA[<h1 id="青春，人生最美好的年华，相信自己，要知道你内心深处的某些东西是比任何困难都要强大。"><a href="#青春，人生最美好的年华，相信自己，要知道你内心深处的某些东西是比任何困难都要强大。" class="headerlink" title="青春，人生最美好的年华，相信自己，要知道你内心深处的某些东西是比任何困难都要强大。"></a>青春，人生最美好的年华，相信自己，要知道你内心深处的某些东西是比任何困难都要强大。</h1>]]></content>
  </entry>
  <entry>
    <title>【Nordic】学习笔记 --&gt; Nordic_development_environment(nRF51 &amp; nRF52 Series)</title>
    <url>/2020/05/06/Nordic-development-environment/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<h3 id="1-强制安装项"><a href="#1-强制安装项" class="headerlink" title="1. 强制安装项"></a>1. 强制安装项</h3><p>​            如下工具必须安装,否则无法开发 nRF51 &amp; nRF52 Series 产品</p>
<h4 id="1-1-安装IDE"><a href="#1-1-安装IDE" class="headerlink" title="1.1   安装IDE"></a>1.1   安装IDE</h4><p>​            Nordic nRF51/52支持Keil，GCC，IAR 和 SES（Segger Embedded Studio）四种IDE，大家随便选择其中一种安装即可。</p>
<h4 id="1-2-安装-nRF-Command-Line-Tools-（支持-Windows-Linux-Mac）"><a href="#1-2-安装-nRF-Command-Line-Tools-（支持-Windows-Linux-Mac）" class="headerlink" title="1.2   安装 nRF Command Line Tools （支持 Windows / Linux / Mac）"></a>1.2   安装 nRF Command Line Tools （支持 Windows / Linux / Mac）</h4><p>​            nRF Command Line Tools ( Nordic官方自己开发的命令行工具 ) , 安装过程中具体组件包括 J-link驱动、nrfjprog、nrfutil、mergehex等。</p>
<p>​            下载连接:  <a href="https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Command-Line-Tools/Download#infotabs" target="_blank" rel="noopener">https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Command-Line-Tools/Download#infotabs</a></p>
<p>​            选择自己的桌面平台及需要的版本 (推荐最新发布的版本):</p>
<p><img src="/2020/05/06/Nordic-development-environment/nRF-Command-Line-Tools.png" alt></p>
]]></content>
      <categories>
        <category>Nordic</category>
      </categories>
      <tags>
        <tag>Nordic</tag>
        <tag>Bluetooth</tag>
        <tag>nRF52</tag>
        <tag>nRF connect</tag>
        <tag>nrfutil</tag>
        <tag>nRF51</tag>
      </tags>
  </entry>
  <entry>
    <title>【RT-Thread】学习笔记 --&gt; STM32 Series BSP Production(BSP制作)</title>
    <url>/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<p>环境介绍</p>
<ul>
<li>操作系统:   Window10 企业版</li>
<li>IDE开发环境:   RT-Thread Studio (Version: 1.1.3)</li>
<li>SDK版本:   STM32H7 (Released V0.1.9)</li>
<li>STM32CubeMX 版本：Version 6.0.1</li>
<li>硬件开发板:   STM32H743IITx 最小系统开发板 (本人自己设计的最小系统)</li>
</ul>
<a id="more"></a>

<h1 id="STM32-Series-BSP-Production-BSP制作教程"><a href="#STM32-Series-BSP-Production-BSP制作教程" class="headerlink" title="STM32 Series BSP Production(BSP制作教程)"></a>STM32 Series BSP Production(BSP制作教程)</h1><h4 id="STM32-Series-BSP-Production-制作方法"><a href="#STM32-Series-BSP-Production-制作方法" class="headerlink" title="STM32 Series BSP Production 制作方法"></a>STM32 Series BSP Production 制作方法</h4><p>BSP 的制作过程分为以下五个步骤：</p>
<ul>
<li>复制通用模板</li>
<li>使用STM32CubeMX工具配置工程</li>
<li>修改 BSP 中的 Kconfig 文件</li>
<li>修改构建工程相关文件</li>
<li>重新生成工程</li>
</ul>
<h4 id="1-复制通用模板"><a href="#1-复制通用模板" class="headerlink" title="1.   复制通用模板"></a>1.   复制通用模板</h4><h5 id="1-1-下载-RT-Thread-源代码"><a href="#1-1-下载-RT-Thread-源代码" class="headerlink" title="1.1 下载 RT-Thread 源代码"></a>1.1 下载 RT-Thread 源代码</h5><p>&emsp;<strong><a href="https://www.rt-thread.org/page/download.html" target="_blank" rel="noopener">下载请点击这里哦 ! ! !</a></strong></p>
<p>&emsp;本人采用 Gitee (码云) 下载方式</p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/RT-Thread_Source_code.png" alt="RT-Thread_Source_code_download_address"></p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/03.png" alt="RT-Thread_Source_code"></p>
<h5 id="1-2-打开源代码模板路径-rt-thread-bsp-stm32-libraries-templates-stm32h7xx。"><a href="#1-2-打开源代码模板路径-rt-thread-bsp-stm32-libraries-templates-stm32h7xx。" class="headerlink" title="1.2 打开源代码模板路径  rt-thread\bsp\stm32\libraries\templates\stm32h7xx。"></a>1.2 打开源代码模板路径  rt-thread\bsp\stm32\libraries\templates\stm32h7xx。</h5><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/04.png" alt="RT-Thread_Source_code_template"></p>
<h5 id="1-3-创建-01-STM32H743-BSP-文件夹，将官方提供的模板-stm32h7xx-拷贝进来。"><a href="#1-3-创建-01-STM32H743-BSP-文件夹，将官方提供的模板-stm32h7xx-拷贝进来。" class="headerlink" title="1.3  创建 01_STM32H743_BSP 文件夹，将官方提供的模板 (stm32h7xx) 拷贝进来。"></a>1.3  创建 01_STM32H743_BSP 文件夹，将官方提供的模板 (stm32h7xx) 拷贝进来。</h5><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/05.png" alt="RT-Thread_Source_code_template"></p>
<h6 id="1-3-1-Board-文件夹下修改的内容"><a href="#1-3-1-Board-文件夹下修改的内容" class="headerlink" title="1.3.1 Board 文件夹下修改的内容"></a>1.3.1 Board 文件夹下修改的内容</h6><table>
<thead>
<tr>
<th align="center">Board 下文件夹/文件</th>
<th align="center">内容修改说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CubeMX_Config</td>
<td align="center">STM32CubeMX工程</td>
</tr>
<tr>
<td align="center">linker_scripts</td>
<td align="center">工程构建相关文件(链接脚本)</td>
</tr>
<tr>
<td align="center">board.c / board.h</td>
<td align="center">SystemClock_Config、Flash Memory Size、RAM Size</td>
</tr>
<tr>
<td align="center">Kconfig</td>
<td align="center">System peripheral resources Configuration</td>
</tr>
<tr>
<td align="center">SConscript</td>
<td align="center">System Chip Startup File</td>
</tr>
</tbody></table>
<h4 id="2-STM32CubeMX-工程配置"><a href="#2-STM32CubeMX-工程配置" class="headerlink" title="2.  STM32CubeMX 工程配置"></a>2.  STM32CubeMX 工程配置</h4><h5 id="2-1-打开-CubeMX-Config-ioc-工程文件"><a href="#2-1-打开-CubeMX-Config-ioc-工程文件" class="headerlink" title="2.1 打开 CubeMX_Config.ioc 工程文件"></a>2.1 打开 CubeMX_Config.ioc 工程文件</h5><p>CubeMX_Config.ioc 工程文件路径：*<em>01_STM32H743_BSP\board\CubeMX_Config\CubeMX_Config.ioc *</em></p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/06.PNG" alt="STM32CubeMX"></p>
<h5 id="2-2-STM32CubeMX-工程生成"><a href="#2-2-STM32CubeMX-工程生成" class="headerlink" title="2.2 STM32CubeMX 工程生成"></a>2.2 STM32CubeMX 工程生成</h5><h6 id="2-2-1-打开外部时钟设置"><a href="#2-2-1-打开外部时钟设置" class="headerlink" title="2.2.1   打开外部时钟设置"></a>2.2.1   打开外部时钟设置</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/07.png" alt="STM32CubeMX"></p>
<h6 id="2-2-2-下载方式配置-SWD"><a href="#2-2-2-下载方式配置-SWD" class="headerlink" title="2.2.2   下载方式配置 (SWD)"></a>2.2.2   下载方式配置 (SWD)</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/08.png" alt="STM32CubeMX"></p>
<h6 id="2-2-3-调试串口配置-UASRT1"><a href="#2-2-3-调试串口配置-UASRT1" class="headerlink" title="2.2.3   调试串口配置 (UASRT1)"></a>2.2.3   调试串口配置 (UASRT1)</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/09.png" alt="STM32CubeMX"></p>
<h6 id="2-2-4-EEPROM-配置-IIC"><a href="#2-2-4-EEPROM-配置-IIC" class="headerlink" title="2.2.4   EEPROM 配置 (IIC)"></a>2.2.4   EEPROM 配置 (IIC)</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/10.png" alt="STM32CubeMX"></p>
<h6 id="2-2-5-系统时钟配置"><a href="#2-2-5-系统时钟配置" class="headerlink" title="2.2.5   系统时钟配置"></a>2.2.5   系统时钟配置</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/11.png" alt="STM32CubeMX"></p>
<h6 id="2-2-6-Project-Manager-设置-基本不需要修改"><a href="#2-2-6-Project-Manager-设置-基本不需要修改" class="headerlink" title="2.2.6   Project Manager 设置 (基本不需要修改)"></a>2.2.6   Project Manager 设置 (基本不需要修改)</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/12.png" alt="STM32CubeMX"></p>
<h6 id="2-2-7-点击-GENERAYE-CODE-直接生成工程"><a href="#2-2-7-点击-GENERAYE-CODE-直接生成工程" class="headerlink" title="2.2.7   点击 GENERAYE CODE 直接生成工程"></a>2.2.7   点击 GENERAYE CODE 直接生成工程</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/13.png" alt="STM32CubeMX"></p>
<h6 id="2-2-8-CubeMX-Config目录下生成的文件如下"><a href="#2-2-8-CubeMX-Config目录下生成的文件如下" class="headerlink" title="2.2.8   CubeMX_Config目录下生成的文件如下"></a>2.2.8   CubeMX_Config目录下生成的文件如下</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/14.png" alt="STM32CubeMX"></p>
<h4 id="3-Board-c-Board-h-文件修改"><a href="#3-Board-c-Board-h-文件修改" class="headerlink" title="3.   Board.c / Board.h 文件修改"></a>3.   Board.c / Board.h 文件修改</h4><h5 id="3-1-SystemClock-Config-函数拷贝-整个系统唯一拷贝的函数"><a href="#3-1-SystemClock-Config-函数拷贝-整个系统唯一拷贝的函数" class="headerlink" title="3.1 SystemClock_Config() 函数拷贝 (整个系统唯一拷贝的函数)"></a>3.1 SystemClock_Config() 函数拷贝 (整个系统唯一拷贝的函数)</h5><p>&emsp;&emsp;board.c 文件中存放了<strong>SystemClock_Config()</strong>函数，该函数负责初始化系统时钟。如果 STM32CubeMX 对系统时钟重新配置，需要重新更新 <strong>SystemClock_Config()</strong> 函数。</p>
<p>&emsp;&emsp;STM32CubeMX工具生成的 <strong>SystemClock_Config()</strong> 函数默认在 CubeMX_Config\Src\main.c，所以我们将main.c 文件中的 <strong>SystemClock_Config()</strong> 函数拷贝到 board.c 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief System Clock Configuration</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SystemClock_Config</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  RCC_OscInitTypeDef RCC_OscInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RCC_ClkInitTypeDef RCC_ClkInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**Supply configuration update enable</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  MODIFY_REG(PWR-&gt;CR3, PWR_CR3_SCUEN, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">/**Configure the main internal regulator output voltage</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ((PWR-&gt;D3CR &amp; (PWR_D3CR_VOSRDY)) != PWR_D3CR_VOSRDY)</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**Initializes the CPU, AHB and APB busses clocks</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;</span><br><span class="line">  RCC_OscInitStruct.HSEState = RCC_HSE_ON;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLM = <span class="number">5</span>;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLN = <span class="number">160</span>;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLP = <span class="number">2</span>;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLQ = <span class="number">2</span>;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLR = <span class="number">2</span>;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;</span><br><span class="line">  RCC_OscInitStruct.PLL.PLLFRACN = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**Initializes the CPU, AHB and APB busses clocks</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK</span><br><span class="line">                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2</span><br><span class="line">                              |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;</span><br><span class="line">  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;</span><br><span class="line">  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;</span><br><span class="line">  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;</span><br><span class="line">  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;</span><br><span class="line">  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;</span><br><span class="line">  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;</span><br><span class="line">  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (HAL_RCC_ClockConfig(&amp;RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">  PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_I2C2;</span><br><span class="line">  PeriphClkInitStruct.Usart16ClockSelection = RCC_USART16CLKSOURCE_D2PCLK2;</span><br><span class="line">  PeriphClkInitStruct.I2c123ClockSelection = RCC_I2C123CLKSOURCE_D2PCLK1;</span><br><span class="line">  <span class="keyword">if</span> (HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInitStruct) != HAL_OK)</span><br><span class="line">  &#123;</span><br><span class="line">    Error_Handler();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-系统芯片-Flash-和-RAM-相关参数配置"><a href="#3-2-系统芯片-Flash-和-RAM-相关参数配置" class="headerlink" title="3.2 系统芯片 Flash 和 RAM 相关参数配置"></a>3.2 系统芯片 Flash 和 RAM 相关参数配置</h5><ul>
<li>STM32_FLASH_SIZE 和 STM32_SRAM_SIZE 两个参数需要修改 (针对实际芯片大小设置)</li>
<li>本 BSP 使用的芯片为 STM32H743IITx 系列，Flash 大小 2024kBytes, RAM 大小 1024kBytes</li>
</ul>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/15.png" alt="board.h"></p>
<h4 id="4-Kconfig-文件修改-初次制作BSP先不着急修改，后续根据Kconfig语法在修改"><a href="#4-Kconfig-文件修改-初次制作BSP先不着急修改，后续根据Kconfig语法在修改" class="headerlink" title="4.  Kconfig 文件修改 (初次制作BSP先不着急修改，后续根据Kconfig语法在修改)"></a>4.  Kconfig 文件修改 (初次制作BSP先不着急修改，后续根据Kconfig语法在修改)</h4><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/16.png" alt="Kconfig"></p>
<h4 id="5-工程构建相关文件修改"><a href="#5-工程构建相关文件修改" class="headerlink" title="5.  工程构建相关文件修改"></a>5.  工程构建相关文件修改</h4><h5 id="5-1-linker-scripts-链接脚本修改"><a href="#5-1-linker-scripts-链接脚本修改" class="headerlink" title="5.1   linker_scripts 链接脚本修改"></a>5.1   linker_scripts 链接脚本修改</h5><p>linker_scripts 文件夹下包含链接脚本，如图下图所示：</p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/17.png" alt="linker_scripts"></p>
<h6 id="5-1-1-MDK-链接脚本修改"><a href="#5-1-1-MDK-链接脚本修改" class="headerlink" title="5.1.1   MDK 链接脚本修改"></a>5.1.1   MDK 链接脚本修改</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/18.png" alt="linker_scripts"></p>
<h6 id="5-1-2-IAR-链接脚本修改"><a href="#5-1-2-IAR-链接脚本修改" class="headerlink" title="5.1.2   IAR 链接脚本修改"></a>5.1.2   IAR 链接脚本修改</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/19.png" alt="linker_scripts"></p>
<h6 id="5-1-3-GCC-链接脚本修改"><a href="#5-1-3-GCC-链接脚本修改" class="headerlink" title="5.1.3   GCC 链接脚本修改"></a>5.1.3   GCC 链接脚本修改</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/20.png" alt="linker_scripts"></p>
<h5 id="5-2-SConscript-脚本修改"><a href="#5-2-SConscript-脚本修改" class="headerlink" title="5.2 SConscript 脚本修改"></a>5.2 SConscript 脚本修改</h5><p>&emsp;&emsp;SConscript 脚本决定 MDK/IAR 工程的生成以及编译过程中要添加文件。</p>
<p>&emsp;&emsp;修改芯片型号以及芯片启动文件的地址：</p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/21.png" alt="SConscript"></p>
<p>&emsp;&emsp;注意：如果在文件夹中找不到相应系列的 .s 文件，可能是多个系列的芯片重用了相同的启动文件，此时可以在 CubeMX 中生成目标芯片的工程，查看使用了哪个启动文件，然后再修改启动文件名。</p>
<h5 id="5-3-工程模板修改"><a href="#5-3-工程模板修改" class="headerlink" title="5.3 工程模板修改"></a>5.3 工程模板修改</h5><h6 id="5-3-1-打开-template-uvprojx-工程"><a href="#5-3-1-打开-template-uvprojx-工程" class="headerlink" title="5.3.1   打开 template.uvprojx 工程"></a>5.3.1   打开 template.uvprojx 工程</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/22.png" alt="MDK"></p>
<h6 id="5-3-2-选择-BSP-使用的芯片型号"><a href="#5-3-2-选择-BSP-使用的芯片型号" class="headerlink" title="5.3.2   选择 BSP 使用的芯片型号"></a>5.3.2   选择 BSP 使用的芯片型号</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/23.png" alt="MDK"></p>
<h6 id="5-3-3-选择并配置下载方式"><a href="#5-3-3-选择并配置下载方式" class="headerlink" title="5.3.3   选择并配置下载方式"></a>5.3.3   选择并配置下载方式</h6><p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/24.png" alt="MDK"></p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/25.png" alt="MDK"></p>
<h5 id="5-4-基于Env重新生成工程"><a href="#5-4-基于Env重新生成工程" class="headerlink" title="5.4   基于Env重新生成工程"></a>5.4   基于Env重新生成工程</h5><p><a href="https://github.com/RT-Thread/rtthread-manual-doc/blob/master/env/env.md" target="_blank" rel="noopener">Env 工具使用及配置，请点这里！！！</a></p>
<p>Env Tools 的路径必须是英文并且路径文件夹不能有空格！！！</p>
<h6 id="5-4-1-重新生成-rtconfig-h-文件"><a href="#5-4-1-重新生成-rtconfig-h-文件" class="headerlink" title="5.4.1 重新生成 rtconfig.h 文件"></a>5.4.1 重新生成 rtconfig.h 文件</h6><p>输入menuconfig 命令后出现如下图所示的情况：</p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/26.png" alt="Env"></p>
<p><strong>注意：针对以上情况如何处理，出现这样的情况是因为脱离了官方源代码 rt-thread\bsp\stm 路径。</strong></p>
<ul>
<li><p>首先，要知道自己下载 RT-Thread 源代码的路径 (本人 RT-Thread 源代码路径：D:\00_RT-Thread\00_RT-Thread_Source_code\rt-thread) </p>
</li>
<li><p>修改第一个 Kconfig 文件</p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/27.png" alt="Env"></p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">config</span> RTT_DIR</span><br><span class="line">     <span class="built_in">string</span></span><br><span class="line">     option env=<span class="string">"RTT_ROOT"</span></span><br><span class="line">     <span class="keyword">default</span> <span class="string">"../../.."</span></span><br><span class="line"> <span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line"> <span class="built_in">config</span> RTT_DIR</span><br><span class="line">     <span class="built_in">string</span></span><br><span class="line">     option env=<span class="string">"RTT_ROOT"</span></span><br><span class="line">     <span class="keyword">default</span> <span class="string">"D:/00_RT-Thread/00_RT-Thread_Source_code/rt-thread"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">source <span class="string">"../libraries/Kconfig"</span></span><br><span class="line">source <span class="string">"board/Kconfig"</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">source <span class="string">"D:/00_RT-Thread/00_RT-Thread_Source_code/rt-thread/bsp/stm32/libraries/Kconfig"</span></span><br><span class="line">source <span class="string">"D:/00_RT-Thread/02_RT-Thread_BSP_Project/01_STM32H743_BSP/board/Kconfig"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/28.png" alt="Env"></p>
<ul>
<li><p>修改第二个 Kconfig 文件</p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/29.png" alt="Env"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">source <span class="string">"../libraries/HAL_Drivers/Kconfig"</span></span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span></span><br><span class="line">source <span class="string">"D:/00_RT-Thread/00_RT-Thread_Source_code/rt-thread/bsp/stm32/libraries/HAL_Drivers/Kconfig"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/30.png" alt="Env"></p>
<p>然后在Env界面再次输入 menuconfig 命令对工程进行配置，并生成  rtconfig.h 文件。</p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/31.png" alt="Env"></p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/32.png" alt="Env"></p>
<h6 id="5-4-2-重新生成-MDK-IAR-工程"><a href="#5-4-2-重新生成-MDK-IAR-工程" class="headerlink" title="5.4.2 重新生成 MDK / IAR 工程"></a>5.4.2 重新生成 MDK / IAR 工程</h6><p>输入 scons 命令后出现如下图所示的情况：</p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/33.png" alt="Env"></p>
<p><strong>注意：针对以上情况如何处理，出现这样的情况是因为脱离了官方源代码 rt-thread\bsp\stm 路径。</strong></p>
<ul>
<li><p>首先，要知道自己下载 RT-Thread 源代码的路径 (本人 RT-Thread 源代码路径：D:\00_RT-Thread\00_RT-Thread_Source_code\rt-thread) </p>
</li>
<li><p>修改 SConstruct 文件</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line">if os.getenv('RTT_ROOT'):</span><br><span class="line">    RTT_ROOT = os.getenv('RTT_ROOT')</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    RTT_ROOT = os.path.normpath(os.getcwd() + '/../../..')</span><br><span class="line">        </span><br><span class="line"><span class="comment">/*-----------------------------------------------------------*/</span> </span><br><span class="line">        </span><br><span class="line">RTT_ROOT = 'D:/00_RT-Thread/00_RT-Thread_Source_code/rt-thread'</span><br></pre></td></tr></table></figure>

 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SDK_ROOT = os.path.abspath(<span class="string">'./'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(SDK_ROOT + <span class="string">'/libraries'</span>):</span><br><span class="line">    libraries_path_prefix = SDK_ROOT + <span class="string">'/libraries'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libraries_path_prefix = os.path.dirname(SDK_ROOT) + <span class="string">'/libraries'</span></span><br><span class="line"></span><br><span class="line">SDK_LIB = libraries_path_prefix</span><br><span class="line">Export(<span class="string">'SDK_LIB'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare building environment</span></span><br><span class="line">objs = PrepareBuilding(env, RTT_ROOT, has_libcpu=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">stm32_library = <span class="string">'STM32H7xx_HAL'</span></span><br><span class="line">rtconfig.BSP_LIBRARY_TYPE = stm32_library</span><br><span class="line"></span><br><span class="line"><span class="comment"># include drivers</span></span><br><span class="line">objs.extend(SConscript(os.path.join(libraries_path_prefix, stm32_library, <span class="string">'SConscript'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># include libraries</span></span><br><span class="line">objs.extend(SConscript(os.path.join(libraries_path_prefix, <span class="string">'HAL_Drivers'</span>, <span class="string">'SConscript'</span>)))</span><br><span class="line">        </span><br><span class="line">/*-----------------------------------------------------------*/ </span><br><span class="line">        </span><br><span class="line">SDK_ROOT = os.path.abspath(<span class="string">'D:/00_RT-Thread/00_RT-Thread_Source_code/rt-thread/bsp/stm32'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(SDK_ROOT + <span class="string">'/libraries'</span>):</span><br><span class="line">    libraries_path_prefix = SDK_ROOT + <span class="string">'/libraries'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    libraries_path_prefix = os.path.dirname(SDK_ROOT) + <span class="string">'/libraries'</span></span><br><span class="line"></span><br><span class="line">SDK_LIB = libraries_path_prefix</span><br><span class="line">Export(<span class="string">'SDK_LIB'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># prepare building environment</span></span><br><span class="line">objs = PrepareBuilding(env, RTT_ROOT, has_libcpu=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">stm32_library = <span class="string">'D:/00_RT-Thread/00_RT-Thread_Source_code/rt-thread/bsp/stm32/libraries/STM32H7xx_HAL'</span></span><br><span class="line">rtconfig.BSP_LIBRARY_TYPE = stm32_library</span><br><span class="line"></span><br><span class="line"><span class="comment"># include drivers</span></span><br><span class="line">objs.extend(SConscript(os.path.join(libraries_path_prefix, stm32_library, <span class="string">'SConscript'</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># include libraries</span></span><br><span class="line">objs.extend(SConscript(os.path.join(libraries_path_prefix, <span class="string">'D:/00_RT-Thread/00_RT-Thread_Source_code/rt-thread/bsp/stm32/libraries/HAL_Drivers'</span>, <span class="string">'SConscript'</span>)))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>然后在Env界面再次输入 <strong>scons –target=mdk5</strong> 命令重新生成工程。</p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/34.png" alt="Env"></p>
<p><img src="/2020/09/10/RT-Thread-BSP%E5%88%B6%E4%BD%9C/35.png" alt="Env"></p>
<p>如果出现以上结果，新的 BSP 已经制作成功了，可以使用了 。 </p>
<h4 id="6-文档参考"><a href="#6-文档参考" class="headerlink" title="6. 文档参考"></a>6. 文档参考</h4><ul>
<li><p><a href="https://github.com/RT-Thread/rt-thread/blob/master/bsp/stm32/docs/STM32%E7%B3%BB%E5%88%97BSP%E5%88%B6%E4%BD%9C%E6%95%99%E7%A8%8B.md" target="_blank" rel="noopener">STM32系列BSP制作教程</a></p>
</li>
<li><p><a href="https://github.com/RT-Thread/rtthread-manual-doc/blob/master/env/env.md" target="_blank" rel="noopener">User Manual of Env</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>RT-Thread</category>
      </categories>
      <tags>
        <tag>RTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>【RT-Thread】学习笔记 --&gt; RT-Thread Studio Project Import</title>
    <url>/2020/09/09/RT-Threadad-Project-import/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<p>环境介绍</p>
<ul>
<li>操作系统:   Window10 企业版</li>
<li>IDE开发环境:   RT-Thread Studio (Version: 1.1.3)</li>
<li>SDK版本:   STM32H7 (Released V0.1.9)</li>
<li>硬件开发板:   STM32H743IITx 最小系统 (本人自己设计的最小系统)</li>
</ul>
<a id="more"></a>

<h1 id="RT-Thread-Studio-Project-Import-导入工程"><a href="#RT-Thread-Studio-Project-Import-导入工程" class="headerlink" title="RT-Thread Studio Project Import (导入工程)"></a>RT-Thread Studio Project Import (导入工程)</h1><h4 id="1-RT-Thread-Studio-项目导入"><a href="#1-RT-Thread-Studio-项目导入" class="headerlink" title="1. RT-Thread Studio 项目导入"></a>1. RT-Thread Studio 项目导入</h4><h5 id="1-1-RT-Thread-Studio-资源管理器窗口中点击右键，在下拉在下拉菜单中选择导入功能。"><a href="#1-1-RT-Thread-Studio-资源管理器窗口中点击右键，在下拉在下拉菜单中选择导入功能。" class="headerlink" title="1.1 RT-Thread Studio 资源管理器窗口中点击右键，在下拉在下拉菜单中选择导入功能。"></a>1.1 RT-Thread Studio 资源管理器窗口中点击右键，在下拉在下拉菜单中选择导入功能。</h5><p><img src="/2020/09/09/RT-Threadad-Project-import/Import.png" alt="Import"></p>
<h5 id="1-2-打开导入功能向导，选择导入RT-Thread-Studio-工程，点击下一步。"><a href="#1-2-打开导入功能向导，选择导入RT-Thread-Studio-工程，点击下一步。" class="headerlink" title="1.2 打开导入功能向导，选择导入RT-Thread Studio 工程，点击下一步。"></a>1.2 打开导入功能向导，选择导入RT-Thread Studio 工程，点击下一步。</h5><p><img src="/2020/09/09/RT-Threadad-Project-import/Import_project_select.png" alt="Import project select"></p>
<h5 id="1-3-点击浏览按钮选择要导入项目所在的工程目录，导入程序自动扫描目录下所有可导入的工程，将结果列出在项目列表中，然后点击完成。"><a href="#1-3-点击浏览按钮选择要导入项目所在的工程目录，导入程序自动扫描目录下所有可导入的工程，将结果列出在项目列表中，然后点击完成。" class="headerlink" title="1.3 点击浏览按钮选择要导入项目所在的工程目录，导入程序自动扫描目录下所有可导入的工程，将结果列出在项目列表中，然后点击完成。"></a>1.3 点击浏览按钮选择要导入项目所在的工程目录，导入程序自动扫描目录下所有可导入的工程，将结果列出在项目列表中，然后点击完成。</h5><p><img src="/2020/09/09/RT-Threadad-Project-import/Import_project.png" alt="Import project"></p>
<h4 id="2-MDK-IAR-项目导入"><a href="#2-MDK-IAR-项目导入" class="headerlink" title="2. MDK/IAR 项目导入"></a>2. MDK/IAR 项目导入</h4>]]></content>
      <categories>
        <category>RT-Thread</category>
      </categories>
      <tags>
        <tag>RTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>【STM32CubeMX】学习笔记 --&gt; STM32CubeMX_Usart</title>
    <url>/2020/05/05/STM32CubeMX-Usart/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<p>环境介绍</p>
<ul>
<li>操作系统:   Window10 企业版</li>
<li>IDE开发环境:   STM32CubeIDE 1.2.0</li>
<li>STM32CubeMX版本:   STM32CubeMX Version 5.4.0</li>
<li>Mcu and Firmware Package:   STM32Cube FW_H7 V1.5.0</li>
<li>硬件开发板:   本人自己设计的最小系统</li>
</ul>
<a id="more"></a>

<h4 id="1-打开-STM32CubeMX"><a href="#1-打开-STM32CubeMX" class="headerlink" title="1. 打开 STM32CubeMX"></a>1. 打开 STM32CubeMX</h4><p><img src="/2020/05/05/STM32CubeMX-Usart/0.png" alt></p>
<p><img src="/2020/05/05/STM32CubeMX-Usart/1.png" alt></p>
<h4 id="2-创建工程Project"><a href="#2-创建工程Project" class="headerlink" title="2. 创建工程Project"></a>2. 创建工程Project</h4><p><img src="/2020/05/05/STM32CubeMX-Usart/2.png" alt></p>
<h4 id="3-选择自己MCU的型号"><a href="#3-选择自己MCU的型号" class="headerlink" title="3. 选择自己MCU的型号"></a>3. 选择自己MCU的型号</h4><ul>
<li><strong>本人MCU型号：STM32H743IITx</strong></li>
<li><strong>双击红色区域直接进入配置界面</strong></li>
</ul>
<p><img src="/2020/05/05/STM32CubeMX-Usart/3.png" alt></p>
<h4 id="4-RCC-配置"><a href="#4-RCC-配置" class="headerlink" title="4. RCC 配置"></a>4. RCC 配置</h4><ul>
<li>单击 System Core -&gt; 单击RCC<ul>
<li>RCC Mode and Configuration<ul>
<li>High Speed Clock (HSE) -&gt; Crystal/Ceramic Resonator</li>
<li>Low Speed Clock (LSE) -&gt; Crystal/Ceramic Resonator</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/05/05/STM32CubeMX-Usart/4.png" alt></p>
<h4 id="5-串口USART配置"><a href="#5-串口USART配置" class="headerlink" title="5. 串口USART配置"></a>5. 串口USART配置</h4><ul>
<li><p>单击 Connectivity -&gt; 单击 USART1</p>
<ul>
<li><p>USART1 Mode</p>
<ul>
<li>Mode：Asynchronous</li>
</ul>
</li>
<li><p>USART1 Configuration</p>
<ul>
<li>Parameter Settings（基础配置）<ul>
<li><img src="/2020/05/05/STM32CubeMX-Usart/5.png" alt></li>
</ul>
</li>
<li>NVIC Settings（中断配置）勾选Enabled<ul>
<li><img src="/2020/05/05/STM32CubeMX-Usart/6.png" alt></li>
</ul>
</li>
<li>GPIO Settings （I/O配置）<ul>
<li><strong>PA9</strong> -&gt; USART1_TX  /  <strong>PA10</strong> -&gt; UASRT1_RX</li>
<li>I/O 空闲状态全部上拉（Pull-Up）</li>
<li><img src="/2020/05/05/STM32CubeMX-Usart/7.png" alt></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-时钟树配置（Clock-Configuration）"><a href="#6-时钟树配置（Clock-Configuration）" class="headerlink" title="6. 时钟树配置（Clock Configuration）"></a>6. 时钟树配置（Clock Configuration）</h4><p><img src="/2020/05/05/STM32CubeMX-Usart/8.png" alt></p>
<h4 id="7-生成路径及IDE选择配置"><a href="#7-生成路径及IDE选择配置" class="headerlink" title="7. 生成路径及IDE选择配置"></a>7. 生成路径及IDE选择配置</h4><ul>
<li><p><strong>Project</strong></p>
<ul>
<li><p>Project Name：工程名（根据自己要求来写）</p>
</li>
<li><p>Project Location：生成工程路径（选择自己常用路径）</p>
</li>
<li><p>Toolchain / IDE：开发环境选择（本工程选择STM32CubeIDE开发环境）</p>
<ul>
<li>EWARM</li>
<li>MDK_ARM</li>
<li>SW4STM32</li>
<li>TrueSTUDIO</li>
<li><strong>STM32CubeIDE</strong></li>
<li>MakeFile</li>
</ul>
</li>
<li><p>Mcu and Firmware Package (STM32Cube FW_H7 V1.5.0)</p>
<ul>
<li>MCU Reference：STM32H743IITx</li>
<li>Firmware Package Name and Version：<strong>STM32Cube FW_H7 V1.5.0</strong> （版本不同，生成的工程可能会有点差异）</li>
</ul>
</li>
<li><p><img src="/2020/05/05/STM32CubeMX-Usart/9.png" alt></p>
</li>
</ul>
</li>
<li><p><strong>Code Generator 配置选择</strong> </p>
<p><img src="/2020/05/05/STM32CubeMX-Usart/10.png" alt></p>
</li>
</ul>
<p><strong>至此工程配置基本完成</strong>（单击 GENERATE CODE 生成工程）</p>
<h4 id="8-打开-STM32CubeIDE-编译生成工程"><a href="#8-打开-STM32CubeIDE-编译生成工程" class="headerlink" title="8. 打开 STM32CubeIDE 编译生成工程"></a>8. 打开 STM32CubeIDE 编译生成工程</h4><p><img src="/2020/05/05/STM32CubeMX-Usart/11.png" alt></p>
<h4 id="9-Printf-打印配置"><a href="#9-Printf-打印配置" class="headerlink" title="9. Printf 打印配置"></a>9. Printf 打印配置</h4><ul>
<li><strong>usart.h 添加代码</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>usart.c 添加代码</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes -----------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="comment">/* With GCC/RAISONANCE, small printf (option LD Linker-&gt;Libraries-&gt;Small printf</span></span><br><span class="line"><span class="comment">   set to 'Yes') calls __io_putchar() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __GNUC__ */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Retargets the C library printf function to the USART.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Place your implementation of fputc here */</span></span><br><span class="line">    <span class="comment">/* e.g. write a character to the USART1 and Loop until the end of transmission */</span></span><br><span class="line">    HAL_UART_Transmit(&amp;huart1, (<span class="keyword">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">0xFFFF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/05/STM32CubeMX-Usart/12.png" alt></p>
<p><img src="/2020/05/05/STM32CubeMX-Usart/13.png" alt></p>
<h4 id="10-STM32H743IITx-工程模板"><a href="#10-STM32H743IITx-工程模板" class="headerlink" title="10.  STM32H743IITx 工程模板"></a>10.  STM32H743IITx 工程模板</h4><ul>
<li>工程模板  <a href="https://gitee.com/Zhao_ch/STM32H743_Template_Cubeide" target="_blank" rel="noopener">下载连接</a></li>
</ul>
]]></content>
      <categories>
        <category>STM32CubeMX</category>
      </categories>
      <tags>
        <tag>STM32CubeMX</tag>
        <tag>STM32</tag>
        <tag>HAL</tag>
      </tags>
  </entry>
  <entry>
    <title>【nRF52832】学习笔记 --&gt; TIMER-Timer/Counter (定时器/计数器)</title>
    <url>/2020/08/10/Timer/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<p>环境介绍</p>
<ul>
<li>操作系统:   Window10 企业版</li>
<li>IDE开发环境:   ARM_MDK5 (Keil5)</li>
<li>SDK版本:   SDK_17.0.0 </li>
<li>硬件开发板:   官方开发板 PCA10040</li>
</ul>
<a id="more"></a>

<h2 id="TIMER-Timer-Counter-定时器-计数器"><a href="#TIMER-Timer-Counter-定时器-计数器" class="headerlink" title="TIMER-Timer/Counter (定时器/计数器)"></a>TIMER-Timer/Counter (定时器/计数器)</h2><h4 id="1-概述介绍"><a href="#1-概述介绍" class="headerlink" title="1. 概述介绍"></a>1. 概述介绍</h4><p>&emsp;&emsp;定时器有两种模式：<strong>定时器</strong> 和 <strong>计数器</strong>。定时器和计数器内部结构框图如下：</p>
<p><img src="/2020/08/10/Timer/timer_counter.png" alt="timer_counter"></p>
<p>&emsp;&emsp;不管使用什么 MCU 处理器，都必定含有定时器和计数器，针对Nordic芯片，nRF52xx系列的Timer定时器页十分强大，其内部含有5个定时器，Timer0、Timer1、Timer2、Timer3、Timer4。如果使用蓝牙的话，Timer0是被 BLE 占有的，所以只能使用后边4个定时器，Timer1、Timer2、Timer3、Timer4。</p>
<p><img src="/2020/08/10/Timer/Timer.png" alt="Timer"></p>
<h4 id="2-Timer-Counter-原理分析"><a href="#2-Timer-Counter-原理分析" class="headerlink" title="2. Timer / Counter 原理分析"></a>2. Timer / Counter 原理分析</h4><h5 id="2-1-Timer-Counter-定时器和计数器的区别"><a href="#2-1-Timer-Counter-定时器和计数器的区别" class="headerlink" title="2.1   Timer / Counter 定时器和计数器的区别"></a>2.1   Timer / Counter 定时器和计数器的区别</h5><ul>
<li>定时器和计数器实际都是通过计数器来计数。</li>
<li>定时器是对周期不变的脉冲计数 (一般来自系统时钟)，由计数的个数和脉冲的周期即可计算出时间。同时，通过一个给定的预期值 (即比较值)，当计数值达到预期值时产生中断，这实现了定时，应用程序通过设置不同的预期值实现不同时间的定时。</li>
<li>计数器时对某一事件进行计数，此事件没发生一次，计数值加/减1，事件的产生可能时没有规律的，计数器的用途是对事件发生的次数进行计数，由计数值来反映事件产生的次数。</li>
</ul>
<h5 id="2-2-Timer-时钟源"><a href="#2-2-Timer-时钟源" class="headerlink" title="2.2   Timer 时钟源"></a>2.2   Timer 时钟源</h5><p>&emsp;&emsp;Timer时钟源主要来源是 PCLK1M 或 PCLK16M，系统会自动根据Timer时钟设置的频率 f 自动选择使用哪一种时钟源，时钟源的设置是无需软件操作的，当我们设置好Timer时钟频率后，系统会根据时钟频率自动选择时钟源。</p>
<ul>
<li><p><strong>f <sub>TIMER = 16MHz  /  2<sup>PRESCALER</sup></sub></strong> </p>
</li>
<li><p><strong>f <sub>TIMER &gt; 1MHz</sub></strong>，定时器使用 <strong>PCLK16M</strong> 作为时钟源。</p>
</li>
<li><p><strong>f <sub>TIMER &lt;= 1MHz</sub></strong>，定时器使用 <strong>PCLK1M</strong> 代替 <strong>PCLK16M</strong>，降低功耗。</p>
</li>
</ul>
<h5 id="2-3-Timer-时钟频率"><a href="#2-3-Timer-时钟频率" class="headerlink" title="2.3   Timer 时钟频率"></a>2.3   Timer 时钟频率</h5><p>&emsp;&emsp;Timer 的时钟频率 f <sub>TIMER 计算公式: <strong>f <sub>TIMER = 16MHz  /  2<sup>PRESCALER</sup></sub></strong>，无论时钟源使用的是 PCLK1M 或 PCLK16M ，时钟频率计算都以 <strong>16MHz</strong> 为基准。</sub></p>
<table>
<thead>
<tr>
<th align="center">分频系数</th>
<th align="center">时钟频率</th>
<th align="center">系统时钟源</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">16MHz</td>
<td align="center">PCLK16M</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">8MHz</td>
<td align="center">PCLK16M</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">4MHz</td>
<td align="center">PCLK16M</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2MHz</td>
<td align="center">PCLK16M</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1MHz</td>
<td align="center">PCLK1M</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">500KHz</td>
<td align="center">PCLK1M</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">250KHz</td>
<td align="center">PCLK1M</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">125KHz</td>
<td align="center">PCLK1M</td>
</tr>
<tr>
<td align="center">8</td>
<td align="center">62.5KHz</td>
<td align="center">PCLK1M</td>
</tr>
<tr>
<td align="center">9</td>
<td align="center">31.25KHz</td>
<td align="center">PCLK1M</td>
</tr>
</tbody></table>
<h5 id="2-4-Timer-位宽"><a href="#2-4-Timer-位宽" class="headerlink" title="2.4   Timer 位宽"></a>2.4   Timer 位宽</h5><p>&emsp;&emsp;nRF52832 5个定时器最大位宽都是 32 Bit， BITMODE 寄存器可以设置定时器的位宽。</p>
<table>
<thead>
<tr>
<th align="center">Bit Width ID</th>
<th align="center">Bit Width Select</th>
<th align="center">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="center">16Bit</td>
<td align="center">0</td>
<td align="center">16 bit timer bit width</td>
</tr>
<tr>
<td align="center">8Bit</td>
<td align="center">1</td>
<td align="center">8 bit timer bit width</td>
</tr>
<tr>
<td align="center">24Bit</td>
<td align="center">2</td>
<td align="center">24 bit timer bit width</td>
</tr>
<tr>
<td align="center">32Bit</td>
<td align="center">3</td>
<td align="center">32 bit timer bit width</td>
</tr>
</tbody></table>
<p>定时器频率和定时器位宽建议设置 16MHz 和 32Bit (本人比较懒不想去算了)，也可以根据自己的定时时间及频率来选择合适的值。</p>
<h5 id="2-5-Timer-捕获"><a href="#2-5-Timer-捕获" class="headerlink" title="2.5 Timer 捕获"></a>2.5 Timer 捕获</h5><p>&emsp;&emsp;Timer 中的每一个CC[n]寄存器都对应一个捕获任务 TASKS_CAPTURE，每次出发任务寄存器 CAPTURE[n]，捕获值会被存储到对应的CC[n]寄存器。</p>
<h5 id="2-6-Timer-溢出和清零"><a href="#2-6-Timer-溢出和清零" class="headerlink" title="2.6 Timer 溢出和清零"></a>2.6 Timer 溢出和清零</h5><p>&emsp;&emsp;Timer 计数寄存器的值增加到最大值时，计数寄存器溢出，计数寄存器的数值会清零并自动从零开始计数。出发任务寄存器 CLEAR，计数寄存器的值也会被清零。</p>
<h5 id="2-7-Timer-比较"><a href="#2-7-Timer-比较" class="headerlink" title="2.7 Timer 比较"></a>2.7 Timer 比较</h5><p>&emsp;&emsp;Timer 中每一个CC[n]寄存器都对应一个比较事件 COMPARE，计数值增加到和CC[n]寄存器设置的数值一样时，会产生比较事件 COMPARE[n]。</p>
<h5 id="2-8-Timer-任务延迟和任务优先级"><a href="#2-8-Timer-任务延迟和任务优先级" class="headerlink" title="2.8 Timer 任务延迟和任务优先级"></a>2.8 Timer 任务延迟和任务优先级</h5><ul>
<li>任务延迟：Timer 启动后，CLEAR 任务、COUNT任务、STOP任务会在PCLK16M 的一个时钟周期内生效。</li>
<li>任务优先级：START 任务和 STOP 任务在同一个时钟周期内同时触发时，STOP 任务优先执行。</li>
</ul>
<h4 id="3-Timer-Counter-定时器-计数器-代码实现"><a href="#3-Timer-Counter-定时器-计数器-代码实现" class="headerlink" title="3. Timer/Counter (定时器/计数器) 代码实现"></a>3. Timer/Counter (定时器/计数器) 代码实现</h4><h5 id="3-1-Timer-c-配置"><a href="#3-1-Timer-c-配置" class="headerlink" title="3.1 Timer.c 配置"></a>3.1 Timer.c 配置</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * timer.c</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Created on: 2020-7-17</span></span><br><span class="line"><span class="comment"> *       Author: wuliZhao_ch</span></span><br><span class="line"><span class="comment"> *  Description: library function versions implement timers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"timer.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER0      0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_MS</span></span><br><span class="line"><span class="comment">//#define TIMER_US</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">nrf_drv_timer_t</span> TIMER_TASK = NRF_DRV_TIMER_INSTANCE(<span class="number">0</span>);            <span class="comment">/* Create Timer0 Instance */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Handler for timer events.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_task_event_handler</span><span class="params">(<span class="keyword">nrf_timer_event_t</span> event_type, <span class="keyword">void</span>* p_context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event_type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> NRF_TIMER_EVENT_COMPARE0:          <span class="comment">/* CC[0] Compare event match */</span></span><br><span class="line">            LED_Toggle(LED2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//        case NRF_TIMER_EVENT_COMPARE1:          /* CC[1] Compare event match */</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        case NRF_TIMER_EVENT_COMPARE2:          /* CC[2] Compare event match */</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        case NRF_TIMER_EVENT_COMPARE3:          /* CC[3] Compare event match */</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        case NRF_TIMER_EVENT_COMPARE4:          /* CC[4] Compare event match */</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"><span class="comment">//        case NRF_TIMER_EVENT_COMPARE5:          /* CC[5] Compare event match */</span></span><br><span class="line"><span class="comment">//            break;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// Do nothing.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  HardWare Timer Initialization.</span></span><br><span class="line"><span class="comment"> * @param  Times : timing time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hardWare_timer_init</span><span class="params">(<span class="keyword">uint32_t</span> times)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> time_ticks;</span><br><span class="line">    <span class="keyword">uint32_t</span> err_code = NRF_SUCCESS;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (TIMER_MS)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">nrf_drv_timer_config_t</span> timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG;</span><br><span class="line"></span><br><span class="line">    err_code = nrf_drv_timer_init(&amp;TIMER_TASK, &amp;timer_cfg, timer_task_event_handler);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line"></span><br><span class="line">    time_ticks = nrf_drv_timer_ms_to_ticks(&amp;TIMER_TASK, times);</span><br><span class="line"></span><br><span class="line">    nrf_drv_timer_extended_compare(&amp;TIMER_TASK, NRF_TIMER_CC_CHANNEL0, time_ticks, NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    nrf_drv_timer_enable(&amp;TIMER_TASK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined (TIMER_US)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">nrf_drv_timer_config_t</span> timer_cfg = NRF_DRV_TIMER_DEFAULT_CONFIG;</span><br><span class="line"></span><br><span class="line">    err_code = nrf_drv_timer_init(&amp;TIMER_TASK, &amp;timer_cfg, timer_task_event_handler);</span><br><span class="line">    APP_ERROR_CHECK(err_code);</span><br><span class="line"></span><br><span class="line">    time_ticks = nrf_drv_timer_us_to_ticks(&amp;TIMER_TASK, Times);</span><br><span class="line"></span><br><span class="line">    nrf_drv_timer_extended_compare(&amp;TIMER_TASK, NRF_TIMER_CC_CHANNEL0, time_ticks, NRF_TIMER_SHORT_COMPARE0_CLEAR_MASK, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    nrf_drv_timer_enable(&amp;TIMER_TASK);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-Timer-h-配置"><a href="#3-2-Timer-h-配置" class="headerlink" title="3.2 Timer.h 配置"></a>3.2 Timer.h 配置</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * timer.h</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   Created on: 2020-7-17</span></span><br><span class="line"><span class="comment"> *       Author: wuliZhao_ch</span></span><br><span class="line"><span class="comment"> *  Description: library function versions implement timers</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIMER_H__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_H__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_drv_timer.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"app_error.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"nrf_gpio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"led.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_task_event_handler</span><span class="params">(<span class="keyword">nrf_timer_event_t</span> event_type, <span class="keyword">void</span>* p_context)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hardWare_timer_init</span><span class="params">(<span class="keyword">uint32_t</span> times)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* TIMER_H__ */</span></span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-Main-c-配置"><a href="#3-3-Main-c-配置" class="headerlink" title="3.3 Main.c 配置"></a>3.3 Main.c 配置</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Function for application main entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    nrf_drv_clock_hfclk_request(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(nrf_drv_clock_hfclk_is_running())</span><br><span class="line">    &#123;</span><br><span class="line">        NRF_LOG_INFO(<span class="string">"hfclk_clock_init_succeed!!!\r\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LED_Init();                      <span class="comment">/* Initialize LED */</span></span><br><span class="line">    hardWare_timer_init(<span class="number">1000</span>);       <span class="comment">/* HardWare Timer Initialization */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** @&#125; */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nordic</category>
      </categories>
      <tags>
        <tag>Nordic</tag>
        <tag>Bluetooth</tag>
        <tag>nRF52</tag>
      </tags>
  </entry>
  <entry>
    <title>【Bluetooth】学习笔记 --&gt; 蓝牙空中升级(BLE OTA)原理与步骤</title>
    <url>/2020/06/06/%E8%93%9D%E7%89%99%E7%A9%BA%E4%B8%AD%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<h3 id="蓝牙空中升级-BLE-OTA-原理与步骤"><a href="#蓝牙空中升级-BLE-OTA-原理与步骤" class="headerlink" title="蓝牙空中升级(BLE OTA)原理与步骤"></a>蓝牙空中升级(BLE OTA)原理与步骤</h3><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><ul>
<li><p><strong>DFU</strong>（Device Firmware Update），设备固件升级的意思。</p>
</li>
<li><p><strong>OTA</strong>（Over The Air）是实现DFU的一种方式，准确说OTA全称应该是OTA DFU，即通过空中无线方式实现设备固件升级。</p>
</li>
<li><p>通过无线通信方式实现DFU的，都可以叫OTA，比如 2G / 3G / 4G / WIFI / 蓝牙 / NFC / Zigbee，都支持OTA。</p>
</li>
<li><p>DFU除了可以通过无线方式（OTA）进行升级，也可以通过有线方式进行升级，比如通过UART，USB或者SPI通信接口来升级设备固件。</p>
</li>
<li><p>DFU分为  <strong>后台式</strong>  与  <strong>非后台式</strong></p>
<ul>
<li><strong>后台式DFU：</strong>又称静默式DFU（Silent DFU），升级的时候，新固件在后台悄悄下载，即新固件下载属于应用程序功能的一部分，在新固件下载过程中，应用可以正常使用，也就是说整个下载过程对用户来说是无感的，下载完成后，系统再跳到Bootloader模式，由Bootloader完成新固件覆盖老固件的操作，至此整个升级过程结束。</li>
<li><strong>非后台式DFU：</strong>升级的时候，系统需要先从应用模式跳入到Bootloader模式，由Bootloader进行新固件下载工作，下载完成后Bootloader继续完成新固件覆盖老固件的操作，至此升级结束。早先的功能机就是采用非后台式 DFU来升级操作系统的，即用户需要先长按某些按键进入Bootloader模式，然后再进行升级，整个升级过程中手机正常功能都无法使用。</li>
</ul>
</li>
<li><p><strong>双区DFU</strong>（Dual bank）和<strong>单区DFU</strong>（Single bank），<strong>双区或者单区DFU式新固件和老固件覆盖的两种方式</strong>。</p>
<ul>
<li><p><strong>后台式DFU（双区模式）：</strong>必须采用双区模式进行升级，即老系统（老固件）和新系统（新固件）各占一块Bank（存储区），假设老固件放在Bank0中，新固件放在Bank1中，升级的时候，应用程序先把新固件下载到Bank1中，只有当新固件下载完成并校验成功后，系统才会跳进Bootloader模式，然后擦除老固件所在的Bank0区，并把新固件拷贝到Bank0区中。</p>
</li>
<li><p><strong>非后台式DFU：</strong>可以采用双区模式，也可以采用单区模式</p>
<ul>
<li><p>非后台式DFU（双区模式）：双区模式下新老固件各占一块Bank（老固件为Bank0，新固件为Bank1），升级时，系统先跳入Bootloader模式，然后Bootloader程序把新固件下载到bank1中，只有新固件下载完成并校验成功后，才会去擦除老固件所在的bank0区，并把新固件拷贝到bank0区</p>
</li>
<li><p>非后台式DFU（单区模式）：单区模式的非后台式DFU只有一个Bank0，老固件和新固件分享这一个bank0，升级的时候，进入bootloader模式后<strong>立马擦除老固件</strong>，然后直接把新固件下载到同一个bank中，下载完成后校验新固件的有效性，新固件有效升级完成，否则要求重来。（跟非后台式DFU双区模式相比，单区模式节省了一个Bank的Flash空间，在系统资源比较紧张的时候，单区模式是一个不错的选择）</p>
<p>（不管是双区模式还是单区模式，升级过程出现问题后，都可以进行二次升级，都不会出现“变砖”情况。不过双区模式有一个好处，如果升级过程中出现问题或者新固件有问题，它还可以选择之前的老固件老系统继续执行而不受其影响。而单区模式碰到这种情况就只能一直待在bootloader中，然后等待二次或者多次升级尝试，此时设备的正常功能已无法使用，从用户使用这个角度来说，你的确可以说此时设备已经“变砖”了。所以说，虽然双区模式牺牲了很多存储空间，但是换来了更好的升级体验。）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/06/06/%E8%93%9D%E7%89%99%E7%A9%BA%E4%B8%AD%E5%8D%87%E7%BA%A7/%E5%8D%87%E7%BA%A7%E5%9B%BE%E8%A7%A3.png" alt></p>
<h4 id="二、Nordic-SDK-DFU工作原理"><a href="#二、Nordic-SDK-DFU工作原理" class="headerlink" title="二、Nordic SDK DFU工作原理"></a>二、Nordic SDK DFU工作原理</h4><p><img src="/2020/06/06/%E8%93%9D%E7%89%99%E7%A9%BA%E4%B8%AD%E5%8D%87%E7%BA%A7/nRF_SDK%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.png" alt></p>
<ul>
<li><p><strong>采用双区模式：</strong>Bank0存放的是D程序（老固件），Bank1存放的是新固件。应用程序只在Bank0里跑，Bank1平时为空或者忽略，升级时，先跳转到Bootloader，然后接收新固件并放在Bank1中，最后把Bank1里边的固件拷贝到Bank0中。</p>
</li>
<li><p><strong>采用单区模式：</strong>单区模式则没有Bank1存储区，系统只跑Bank0里面的代码，升级的时候，先跳转到Bootloader，先擦除Bank0里面的程序（老固件），并把新固件直接放在Bank0中。</p>
</li>
</ul>
<p>  <strong>升级时如何跳转到Bootloader？</strong></p>
<p>  ​        Nordic SDK 将DFU分为按键式DFU和非按键式DFU，按键式DFU是上电时长按某按键进入Bootloader模式。非按键式是整个DFU过程中设备端无任何人工干预，通过BLE/UART/USB接口给应用程序发送一条指令，应用程序收到指令后自动进入Bootloader模式。不管是什么方式进入Bootloader，Bootloader工作过程都是一样的。</p>
<p>  <strong>跳转到Bootloader后的执行操作</strong></p>
<p>  ​        程序跳转到Bootloader后，根据Bootloader需不需要对新固件进行验签。（DFU分为开放式DFU和安全式DFU）</p>
<p>  ​        <strong>开放式DFU：</strong> Bootloader不做任何验证，直接把新固件进行升级。</p>
<p>  ​        <strong>安全式DFU：</strong> Bootloader存有一把公钥，Bootloader会先把公钥验证新固件的签名，验签通过，允许后续的工作。（如果验签失败，Bootloader将拒绝升级，重新跳回应用程序）</p>
<p>  目前SDK支持Bluetooth、UART、USB三种方式接受新固件，官方SDK中可以找到此三种方式的工程目录。</p>
<p>  nRF51/52启动流程：<br>          系统上电之后，系统先执行Softdevice，Softdevice通过读取UICR寄存器的一个值，来判断系统目前是否有Bootloader，如果没有Bootloader，系统直接跳到Application；如果有Bootloader，系统先跳到Bootloader，Bootloader再根据相关情况来决定是进入升级模式还是进入Application。<br>          <strong>Bootloader主要判断如下几种情况：<br>                  按键是否按下（按键进入Bootloader DFU）<br>                  保持寄存器GPREGRET1是否为 0xB1<br>                  上次DFU过程是否还在进行<br>                  应用程序校验是否通过</strong></p>
]]></content>
      <categories>
        <category>Nordic</category>
      </categories>
      <tags>
        <tag>Nordic</tag>
        <tag>Bluetooth</tag>
        <tag>nRF52</tag>
        <tag>nRF connect</tag>
        <tag>nrfutil</tag>
        <tag>nRF51</tag>
      </tags>
  </entry>
  <entry>
    <title>嘉立创JLC元件库+3D封装下载</title>
    <url>/2020/05/04/%E5%98%89%E7%AB%8B%E5%88%9BJLC%E5%85%83%E4%BB%B6%E5%BA%93-3D%E5%B0%81%E8%A3%85%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<h3 id="嘉立创JLC元件库-3D封装下载三种方法"><a href="#嘉立创JLC元件库-3D封装下载三种方法" class="headerlink" title="嘉立创JLC元件库+3D封装下载三种方法"></a>嘉立创JLC元件库+3D封装下载三种方法</h3><h4 id="1-下载方法1-使用Git-无需密码"><a href="#1-下载方法1-使用Git-无需密码" class="headerlink" title="1. 下载方法1:  使用Git   无需密码"></a>1. 下载方法1:  使用Git   <strong>无需密码</strong></h4><ul>
<li>Altium Designer:   <a href="https://gitee.com/JLC_SMT/JLCSMT_LIB.git" target="_blank" rel="noopener">https://gitee.com/JLC_SMT/JLCSMT_LIB.git</a>    </li>
</ul>
<h4 id="2-下载方法2：使用SVN方式-可联网同步-检出需要注册-gitee-的账号密码"><a href="#2-下载方法2：使用SVN方式-可联网同步-检出需要注册-gitee-的账号密码" class="headerlink" title="2. 下载方法2：使用SVN方式,可联网同步 检出需要注册 gitee 的账号密码"></a>2. 下载方法2：使用SVN方式,可联网同步 <strong>检出需要注册 gitee 的账号密码</strong></h4><ul>
<li>SVN端口:   <a href="svn://gitee.com/JLC_SMT/JLCSMT_LIB">svn://gitee.com/JLC_SMT/JLCSMT_LIB</a></li>
</ul>
<h4 id="3-下载方法3：手动下载-不能同步-错误无法及时修正-但可以下载"><a href="#3-下载方法3：手动下载-不能同步-错误无法及时修正-但可以下载" class="headerlink" title="3.  下载方法3：手动下载 不能同步,错误无法及时修正, 但可以下载"></a>3.  下载方法3：手动下载 不能同步,错误无法及时修正, 但可以下载</h4>]]></content>
      <categories>
        <category>Altium Designer</category>
      </categories>
      <tags>
        <tag>PCB_Design</tag>
        <tag>Altium Designer</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title>【ZYNQ】学习笔记 --&gt; Install Vivado under Windows（Windows下安装Vivado）</title>
    <url>/2022/09/10/Zynq-Installation-Notes/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<p>环境介绍</p>
<ul>
<li>操作系统：Window11 企业版</li>
<li>软件版本：Vivado 2022.1</li>
</ul>
<a id="more"></a>

<h1 id="Vivado-Installation-Tutorial-Vivado安装教程"><a href="#Vivado-Installation-Tutorial-Vivado安装教程" class="headerlink" title="Vivado Installation Tutorial(Vivado安装教程)"></a>Vivado Installation Tutorial(Vivado安装教程)</h1><h4 id="Xilinx-官网下载-Vivado-地址："><a href="#Xilinx-官网下载-Vivado-地址：" class="headerlink" title="Xilinx 官网下载 Vivado 地址："></a>Xilinx 官网下载 Vivado 地址：</h4><p> &emsp;<strong><a href="https://china.xilinx.com/support/download.html" target="_blank" rel="noopener">下载请点击这里哦!!!</a></strong></p>
<h4 id="1-下载Vivado完成安装包"><a href="#1-下载Vivado完成安装包" class="headerlink" title="1. 下载Vivado完成安装包"></a>1. 下载Vivado完成安装包</h4><img src="/2022/09/10/Zynq-Installation-Notes/Download_Address.png?" alt="Download_Address" style="zoom:70%;">

<p><font color="red" size="5" face="楷体">注意：这个完成的软件包下载时间较长，请耐心等待…</font></p>
<p>Vivado 提供了Linux版本和Windows版本，还提供了二合一版本的，这里使用二合一版本的，既满足Windows开发又满足Linux开发。</p>
<h4 id="2-Windows下开始安装Vivado软件"><a href="#2-Windows下开始安装Vivado软件" class="headerlink" title="2. Windows下开始安装Vivado软件"></a>2. Windows下开始安装Vivado软件</h4><h5 id="2-1-下载解压-Xilinx-Unified-2022-1-0420-0327-tar-gz-软件包，此文件可能比较大，选用较大的磁盘空间解压"><a href="#2-1-下载解压-Xilinx-Unified-2022-1-0420-0327-tar-gz-软件包，此文件可能比较大，选用较大的磁盘空间解压" class="headerlink" title="2.1 下载解压 Xilinx_Unified_2022.1_0420_0327.tar.gz 软件包，此文件可能比较大，选用较大的磁盘空间解压"></a>2.1 下载解压 Xilinx_Unified_2022.1_0420_0327.tar.gz 软件包，此文件可能比较大，选用较大的磁盘空间解压</h5><img src="/2022/09/10/Zynq-Installation-Notes/Software_Package.png">

<h5 id="2-2-打开解压后的文件夹，直接双击-Xsetup-exe-进行安装-安装的过程中-关闭所有杀毒软件-电脑的用户名必须是英文，不能有中文及空格"><a href="#2-2-打开解压后的文件夹，直接双击-Xsetup-exe-进行安装-安装的过程中-关闭所有杀毒软件-电脑的用户名必须是英文，不能有中文及空格" class="headerlink" title="2.2 打开解压后的文件夹，直接双击 Xsetup.exe 进行安装,安装的过程中,关闭所有杀毒软件, 电脑的用户名必须是英文，不能有中文及空格"></a>2.2 打开解压后的文件夹，直接双击 <font color="red" face="黑体">Xsetup.exe</font> 进行安装,安装的过程中,关闭所有杀毒软件,<font color="red"> 电脑的用户名必须是英文，不能有中文及空格</font></h5><img src="/2022/09/10/Zynq-Installation-Notes/Install_file.png">

<h5 id="2-3-双击-Xsetup-exe-之后-出现-Welcome-界面，打开之后如果不是最新版本软件，会提示是否安装最新软件，此时忽略即可，直接点击-Next-即可"><a href="#2-3-双击-Xsetup-exe-之后-出现-Welcome-界面，打开之后如果不是最新版本软件，会提示是否安装最新软件，此时忽略即可，直接点击-Next-即可" class="headerlink" title="2.3 双击 Xsetup.exe 之后,出现 Welcome 界面，打开之后如果不是最新版本软件，会提示是否安装最新软件，此时忽略即可，直接点击 Next 即可."></a>2.3 双击 Xsetup.exe 之后,出现 Welcome 界面，打开之后如果不是最新版本软件，会提示是否安装最新软件，此时忽略即可，直接点击 <font color="red">Next</font> 即可.</h5><img src="/2022/09/10/Zynq-Installation-Notes/Install_file1.png">

<h5 id="2-4-Select-Product-to-Install（选择要安装的产品），选择-Vitis-进行安装，直接点击Next-即可"><a href="#2-4-Select-Product-to-Install（选择要安装的产品），选择-Vitis-进行安装，直接点击Next-即可" class="headerlink" title="2.4 Select Product to Install（选择要安装的产品），选择 Vitis 进行安装，直接点击Next 即可."></a>2.4 Select Product to Install（选择要安装的产品），选择 Vitis 进行安装，直接点击<font color="red">Next</font> 即可.</h5><ul>
<li><font color="red">注意:</font> 在此声明，Vitis 安装过程中包含了 Vivado 的安装，如果不安装 Vitis ，在开发过程中你会发现不能运行 SDK IED，所以安装的时候直接选 Vitis 即可。</li>
</ul>
<img src="/2022/09/10/Zynq-Installation-Notes/Vitis.jpg">

<h5 id="2-5-Vitis-Unified-Software-Platform（Vitis统一软件平台），全部安装占用空间比较大，根据自己需求选择即可，选择完成之后直接点击-Next"><a href="#2-5-Vitis-Unified-Software-Platform（Vitis统一软件平台），全部安装占用空间比较大，根据自己需求选择即可，选择完成之后直接点击-Next" class="headerlink" title="2.5 Vitis Unified Software Platform（Vitis统一软件平台），全部安装占用空间比较大，根据自己需求选择即可，选择完成之后直接点击  Next ."></a>2.5 Vitis Unified Software Platform（Vitis统一软件平台），全部安装占用空间比较大，根据自己需求选择即可，选择完成之后直接点击 <font color="red"> Next </font>.</h5><ul>
<li>在此界面你会观察到，选择 Vitis 安装产品，会默认安装 Vivado 软件。</li>
</ul>
<img src="/2022/09/10/Zynq-Installation-Notes/Vitis2.jpg">

<h5 id="2-7-Accept-License-Agreements（接受许可协议），全选-I-Agree，点击-Next"><a href="#2-7-Accept-License-Agreements（接受许可协议），全选-I-Agree，点击-Next" class="headerlink" title="2.7 Accept License Agreements（接受许可协议），全选 I Agree，点击 Next ."></a>2.7 Accept License Agreements（接受许可协议），全选 I Agree，点击<font color="red"> Next </font>.</h5><img src="/2022/09/10/Zynq-Installation-Notes/Vitis_3.jpg">

<h5 id="2-8-Select-Destination-Directory（选择目标目录），默认选择C盘，以下显示警告，是因为已经安装过，根据自己硬盘大小选择安装目录即可，点击-Next"><a href="#2-8-Select-Destination-Directory（选择目标目录），默认选择C盘，以下显示警告，是因为已经安装过，根据自己硬盘大小选择安装目录即可，点击-Next" class="headerlink" title="2.8 Select Destination Directory（选择目标目录），默认选择C盘，以下显示警告，是因为已经安装过，根据自己硬盘大小选择安装目录即可，点击  Next ."></a>2.8 Select Destination Directory（选择目标目录），默认选择C盘，以下显示警告，是因为已经安装过，根据自己硬盘大小选择安装目录即可，点击 <font color="red"> Next</font> .</h5><img src="/2022/09/10/Zynq-Installation-Notes/Install_file6.png">

<h5 id="2-9-点击-“Install”-，进行安装"><a href="#2-9-点击-“Install”-，进行安装" class="headerlink" title="2.9 点击  “Install” ，进行安装."></a>2.9 点击 <font color="red"> “Install” </font>，进行安装.</h5><h5 id="2-10-等待安装完成，安装时间较长，请耐心等待，安装过程中没有关闭杀毒软件，可能会被拦截，导致安装软件失败不能使用"><a href="#2-10-等待安装完成，安装时间较长，请耐心等待，安装过程中没有关闭杀毒软件，可能会被拦截，导致安装软件失败不能使用" class="headerlink" title="2.10 等待安装完成，安装时间较长，请耐心等待，安装过程中没有关闭杀毒软件，可能会被拦截，导致安装软件失败不能使用."></a>2.10 等待安装完成，安装时间较长，请耐心等待，安装过程中没有关闭杀毒软件，可能会被拦截，导致安装软件失败不能使用.</h5><img src="/2022/09/10/Zynq-Installation-Notes/Vitis1.jpg">

<h5 id="2-11-安装过程中会提示断开下载器或者开发板-JTAG-线，点击-“确认”"><a href="#2-11-安装过程中会提示断开下载器或者开发板-JTAG-线，点击-“确认”" class="headerlink" title="2.11 安装过程中会提示断开下载器或者开发板 JTAG 线，点击 “确认”."></a>2.11 安装过程中会提示断开下载器或者开发板 JTAG 线，点击 <font color="red">“确认”</font>.</h5><h5 id="2-12-安装完成会提示-“Installation-completed-successfully”，点击-“确认”"><a href="#2-12-安装完成会提示-“Installation-completed-successfully”，点击-“确认”" class="headerlink" title="2.12 安装完成会提示 “Installation completed successfully”，点击 “确认”."></a>2.12 安装完成会提示 <font color="red">“Installation completed successfully”</font>，点击 <font color="red">“确认”</font>.</h5><h4 id="3-安装-License-文件"><a href="#3-安装-License-文件" class="headerlink" title="3. 安装 License 文件"></a>3. 安装 License 文件</h4><h5 id="3-1-点击-“Load-License-gt-Copy-License…”"><a href="#3-1-点击-“Load-License-gt-Copy-License…”" class="headerlink" title="3.1 点击 “Load License -&gt; Copy License…”."></a>3.1 点击 <font color="red">“Load License -&gt; Copy License…”</font>.</h5><img src="/2022/09/10/Zynq-Installation-Notes/License1.png">

<h5 id="3-2-选择-”xilinx-ise-vivado-lic“文件，许可文件下载-提取码-bvol"><a href="#3-2-选择-”xilinx-ise-vivado-lic“文件，许可文件下载-提取码-bvol" class="headerlink" title="3.2 选择 ”xilinx_ise_vivado.lic“文件，许可文件下载  提取码: bvol"></a>3.2 选择 ”xilinx_ise_vivado.lic“文件，许可文件下载  <strong><a href="https://pan.baidu.com/s/1wwczHot-cfgQt6XV-ZZblw" target="_blank" rel="noopener">提取码: bvol</a></strong></h5><h5 id="3-3-安装成功提示，点击-“确认”"><a href="#3-3-安装成功提示，点击-“确认”" class="headerlink" title="3.3 安装成功提示，点击 “确认”"></a>3.3 安装成功提示，点击 <font color="red">“确认”</font></h5><img src="/2022/09/10/Zynq-Installation-Notes/License2.png">

<h4 id="4-USB-Serial-Converter-驱动安装"><a href="#4-USB-Serial-Converter-驱动安装" class="headerlink" title="4. USB Serial Converter 驱动安装"></a>4. USB Serial Converter 驱动安装</h4><h5 id="4-1-安装-Vivado-的过程中，会安装下载器驱动，如果没有此驱动需安装下载器驱动，驱动路径：“C-Xilinx-Vivado-2022-1-data-xicom-cable-drivers-nt64-digilent-install-digilent-exe”"><a href="#4-1-安装-Vivado-的过程中，会安装下载器驱动，如果没有此驱动需安装下载器驱动，驱动路径：“C-Xilinx-Vivado-2022-1-data-xicom-cable-drivers-nt64-digilent-install-digilent-exe”" class="headerlink" title="4.1 安装 Vivado 的过程中，会安装下载器驱动，如果没有此驱动需安装下载器驱动，驱动路径：“C:\Xilinx\Vivado\2022.1\data\xicom\cable_drivers\nt64\digilent\install_digilent.exe”"></a>4.1 安装 Vivado 的过程中，会安装下载器驱动，如果没有此驱动需安装下载器驱动，驱动路径：<font color="red">“C:\Xilinx\Vivado\2022.1\data\xicom\cable_drivers\nt64\digilent\install_digilent.exe”</font></h5><img src="/2022/09/10/Zynq-Installation-Notes/USB_Serial_Converter1.png">

<h5 id="4-2-双击-“install-digilent-exe”-安装，安装成功之后，连接下载器，打开设备管理器出现-“USB-Serial-Converter”-此时证明安装成功"><a href="#4-2-双击-“install-digilent-exe”-安装，安装成功之后，连接下载器，打开设备管理器出现-“USB-Serial-Converter”-此时证明安装成功" class="headerlink" title="4.2 双击 “install_digilent.exe” 安装，安装成功之后，连接下载器，打开设备管理器出现 “USB Serial Converter”,此时证明安装成功"></a>4.2 双击 <font color="red">“install_digilent.exe”</font> 安装，安装成功之后，连接下载器，打开设备管理器出现 <font color="red">“USB Serial Converter”</font>,此时证明安装成功</h5><img src="/2022/09/10/Zynq-Installation-Notes/USB_Serial_Converter.png">

<h4 id="整个安装过程如上述描述！！！"><a href="#整个安装过程如上述描述！！！" class="headerlink" title="整个安装过程如上述描述！！！"></a><font color="blue" size="10" face="楷体">整个安装过程如上述描述！！！</font></h4>]]></content>
      <categories>
        <category>Zynq</category>
      </categories>
      <tags>
        <tag>Vivado</tag>
      </tags>
  </entry>
  <entry>
    <title>【ZYNQ】学习笔记 --&gt; Serial Port Prints &quot;Hello World&quot;</title>
    <url>/2022/09/19/Zynq-Uart-Hello-World/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<p>环境介绍</p>
<ul>
<li>操作系统：Window11 企业版</li>
<li>软件版本：Vivado 2022.1</li>
</ul>
<a id="more"></a>

<h1 id="Serial-Port-Prints-“Hello-World”-串口打印”HelloWorld”"><a href="#Serial-Port-Prints-“Hello-World”-串口打印”HelloWorld”" class="headerlink" title="Serial Port Prints “Hello World”(串口打印”HelloWorld”)"></a>Serial Port Prints “Hello World”(串口打印”HelloWorld”)</h1><h4 id="1-Create-Project-创建工程"><a href="#1-Create-Project-创建工程" class="headerlink" title="1. Create Project (创建工程)"></a>1. Create Project (创建工程)</h4><h5 id="1-1-打开-Vivado-软件，点击-“Quick-Start”-标题栏下-“Create-Project”，进入创建-Vivado-工程向导界面，点击-“Next”-进行下一步。"><a href="#1-1-打开-Vivado-软件，点击-“Quick-Start”-标题栏下-“Create-Project”，进入创建-Vivado-工程向导界面，点击-“Next”-进行下一步。" class="headerlink" title="1.1 打开 Vivado 软件，点击 “Quick Start” 标题栏下 “Create Project”，进入创建 Vivado 工程向导界面，点击 “Next” 进行下一步。"></a>1.1 打开 Vivado 软件，点击 <font color="red">“Quick Start”</font> 标题栏下 <font color="red">“Create Project”</font>，进入创建 Vivado 工程向导界面，点击 <font color="red">“Next”</font> 进行下一步。</h5><img src="/2022/09/19/Zynq-Uart-Hello-World/CreateProject.png" style="zoom:45%;">

<img src="/2022/09/19/Zynq-Uart-Hello-World/CreateProject0.png" style="zoom:68%;">

<h5 id="1-2-进入-Project-Name-界面，填写工程名字，工程保存路径，勾选-“Create-project-subdirectory”-会创建本次工程的子目录（工程名和路径只能由英文字母、数字下划线构成，不能包含特殊字符、中文及空格），点击-“Next”-进行下一步。"><a href="#1-2-进入-Project-Name-界面，填写工程名字，工程保存路径，勾选-“Create-project-subdirectory”-会创建本次工程的子目录（工程名和路径只能由英文字母、数字下划线构成，不能包含特殊字符、中文及空格），点击-“Next”-进行下一步。" class="headerlink" title="1.2 进入 Project Name 界面，填写工程名字，工程保存路径，勾选 “Create project subdirectory” , 会创建本次工程的子目录（工程名和路径只能由英文字母、数字下划线构成，不能包含特殊字符、中文及空格），点击 “Next” 进行下一步。"></a>1.2 进入 Project Name 界面，填写工程名字，工程保存路径，勾选 <font color="red">“Create project subdirectory”</font> , 会创建本次工程的子目录（工程名和路径只能由英文字母、数字下划线构成，不能包含特殊字符、中文及空格），点击 <font color="red">“Next”</font> 进行下一步。</h5><img src="/2022/09/19/Zynq-Uart-Hello-World/CreateProject1.png" style="zoom:68%;">

<h5 id="1-3-进入-Project-Type-界面，勾选-“RTL-Project”，本次实验不许添加源文件和约束文件，勾选-“Do-not-specify-sources-at-this-time”-即可，点击-“Next”-进行下一步。"><a href="#1-3-进入-Project-Type-界面，勾选-“RTL-Project”，本次实验不许添加源文件和约束文件，勾选-“Do-not-specify-sources-at-this-time”-即可，点击-“Next”-进行下一步。" class="headerlink" title="1.3 进入 Project Type 界面，勾选 “RTL Project”，本次实验不许添加源文件和约束文件，勾选 “Do not specify sources at this time” 即可，点击 “Next” 进行下一步。"></a>1.3 进入 Project Type 界面，勾选 <font color="red">“RTL Project”</font>，本次实验不许添加源文件和约束文件，勾选 <font color="red">“Do not specify sources at this time”</font> 即可，点击 <font color="red">“Next”</font> 进行下一步。</h5><img src="/2022/09/19/Zynq-Uart-Hello-World/CreateProject2.png" style="zoom:68%;">

<h5 id="1-4-进入-Chip-selection-界面，本实验使用的是-“XC7Z020CLG400”，这里和自己使用的芯片型号保持一致即可，点击-“Next”-进行下一步。"><a href="#1-4-进入-Chip-selection-界面，本实验使用的是-“XC7Z020CLG400”，这里和自己使用的芯片型号保持一致即可，点击-“Next”-进行下一步。" class="headerlink" title="1.4 进入 Chip selection 界面，本实验使用的是 “XC7Z020CLG400”，这里和自己使用的芯片型号保持一致即可，点击 “Next” 进行下一步。"></a>1.4 进入 Chip selection 界面，本实验使用的是 <font color="red">“XC7Z020CLG400”</font>，这里和自己使用的芯片型号保持一致即可，点击 <font color="red">“Next”</font> 进行下一步。</h5><img src="/2022/09/19/Zynq-Uart-Hello-World/CreateProject3.png" style="zoom:68%;">

<h5 id="1-5-进入-Engineering-Summary-工程摘要-界面，显示创建工程的相关信息，点击-“Finish”-完成工程创建。"><a href="#1-5-进入-Engineering-Summary-工程摘要-界面，显示创建工程的相关信息，点击-“Finish”-完成工程创建。" class="headerlink" title="1.5 进入 Engineering Summary(工程摘要)界面，显示创建工程的相关信息，点击 “Finish” 完成工程创建。"></a>1.5 进入 Engineering Summary(工程摘要)界面，显示创建工程的相关信息，点击 <font color="red">“Finish”</font> 完成工程创建。</h5><img src="/2022/09/19/Zynq-Uart-Hello-World/CreateProject4.png" style="zoom:68%;">

<img src="/2022/09/19/Zynq-Uart-Hello-World/CreateProject5.png" style="zoom:68%;">]]></content>
      <categories>
        <category>Zynq</category>
      </categories>
      <tags>
        <tag>Vivado</tag>
      </tags>
  </entry>
</search>
