<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GPIOTE</title>
    <url>/2020/08/06/GPIOTE/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<p>环境介绍</p>
<ul>
<li>操作系统:   Window10 企业版</li>
<li>IDE开发环境:   ARM_MDK5 (Keil5)</li>
<li>SDK版本:   SDK_17.0.0 </li>
<li>硬件开发板:   官方开发板 PCA10040</li>
</ul>
<a id="more"></a>

<h4 id="1-概述介绍"><a href="#1-概述介绍" class="headerlink" title="1. 概述介绍"></a>1. 概述介绍</h4><p>  GPIOTE 驱动控制 GPIO 和 GPIOTE 外设,并配置和控制输出和输入引脚。可以将输出引脚配置玮手动控制或者通过 GPIOTE 任务进行控制。输入引脚可以配置在不同模式下进行控制。</p>
<h4 id="2-GPIOTE-代码实现"><a href="#2-GPIOTE-代码实现" class="headerlink" title="2. GPIOTE 代码实现"></a>2. GPIOTE 代码实现</h4><h5 id="2-1-Sdk-config-h-配置"><a href="#2-1-Sdk-config-h-配置" class="headerlink" title="2.1   Sdk_config.h 配置"></a>2.1   Sdk_config.h 配置</h5><h6 id="2-1-1-Registers-寄存器版本"><a href="#2-1-1-Registers-寄存器版本" class="headerlink" title="2.1.1   Registers (寄存器版本)"></a>2.1.1   Registers (寄存器版本)</h6><p>  如果配置寄存器版本的话，不许需要在Sdk_config.h文件中配置。</p>
<h6 id="2-1-2-Library-库版本"><a href="#2-1-2-Library-库版本" class="headerlink" title="2.1.2   Library (库版本)"></a>2.1.2   Library (库版本)</h6><ol>
<li><p>添加 GPIOTE 驱动文件 nrfx_gpiote.c ，SDK 路径目录：…\modules\nrfx\drivers\src\nrfx_gpiote.c </p>
</li>
<li><p>头文件引用 “nrf_drv_gpiote.h”。</p>
</li>
<li><p>添加头文件路径:</p>
<ul>
<li><strong>…\modules\nrfx\drivers\include</strong></li>
<li><strong>…\integration\nrfx\legacy</strong></li>
</ul>
</li>
<li><p>Sdk_config.h 文件配置</p>
<ul>
<li><p>Text Editor 配置</p>
<ul>
<li>GPIOTE_ENABLED   <strong>0</strong></li>
<li>GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS   <strong>4</strong></li>
<li>GPIOTE_CONFIG_IRQ_PRIORITY   <strong>1</strong></li>
<li>NRFX_GPIOTE_ENABLED   <strong>1</strong></li>
<li>NRFX_GPIOTE_CONFIG_NUM_OF_LOW_POWER_EVENTS   <strong>1</strong></li>
<li>NRFX_GPIOTE_CONFIG_IRQ_PRIORITY   <strong>1</strong></li>
<li>NRFX_GPIOTE_CONFIG_LOG_ENABLED   <strong>0</strong></li>
<li>NRFX_GPIOTE_CONFIG_LOG_LEVEL   <strong>3</strong></li>
<li>NRFX_GPIOTE_CONFIG_INFO_COLOR   <strong>0</strong></li>
<li>NRFX_GPIOTE_CONFIG_DEBUG_COLOR   <strong>0</strong></li>
</ul>
</li>
<li><p>Configuration Wizard 配置</p>
<p><img src="/2020/08/06/GPIOTE/GPIOTE.png" alt="GPIOTE"></p>
</li>
</ul>
</li>
</ol>
<pre><code>![NRFX_GPIOTE](GPIOTE/NRFX_GPIOTE.png)</code></pre><h5 id="2-2-GPIOTE-Registers-寄存器版本"><a href="#2-2-GPIOTE-Registers-寄存器版本" class="headerlink" title="2.2   GPIOTE Registers (寄存器版本)"></a>2.2   GPIOTE Registers (寄存器版本)</h5><h5 id="2-3-GPIOTE-Library-库版本"><a href="#2-3-GPIOTE-Library-库版本" class="headerlink" title="2.3   GPIOTE Library (库版本)"></a>2.3   GPIOTE Library (库版本)</h5>]]></content>
      <categories>
        <category>Nordic</category>
      </categories>
      <tags>
        <tag>Nordic</tag>
        <tag>Bluetooth</tag>
        <tag>nRF52</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 分支管理 (Git_Flow)</title>
    <url>/2020/05/08/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-Git-Flow/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<ul>
<li><p>主分支Master：</p>
<pre><code>代码库应该有一个，且仅有一个主分支。(提供给用户的正式版本，都在主分支上发布(有版本标签))</code></pre></li>
<li><p>开发分支Develop：</p>
<pre><code>主分支只用来发布重大版本，日常开发应该在另一条分支(即开发分支（Develop))
Git创建Develop分支命令：
    git checkout -b develop master
Develop分支合并到Master分支命令：
# 切换到Master分支：
    git checkout master
# 对Develop分支进行合并
    git merge --no-ff develop
（--no-ff参数：默认情况下，Git执行&quot;快进式合并&quot; Fast-Farward merge 直接将Master分支指向Develop分支）</code></pre></li>
<li><p>临时性分支：</p>
<pre><code>Master 和 Develop，前者用于正式发布，后者用于日常开发。除了常设分支以外，还有一些临时分支，用于应用一些特定目的的版本开发。临时性分支有三种：
    功能（feature）分支
    预发布（release）分支
    修补bug（fixbug）分支
（这三种分支属于临时性需要，使用完成之后，应该删除，使得代码库的常设分支始终只有Master和Develop分支）

1. 功能分支：
    功能分支，是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要合并到Develop分支上。(功能分支的名字，可以采用feature-*的形式命名)
    Git 创建一个功能分支：
        git checkout -b feature-x develop
    开发完成后，将功能分支合并到develop分支：
        git checkout develop
        git merge --no-ff feature-x
    删除featur-x分支：
        git branch -d feature-x

2. 预发布分支：
    指发布正式版本之前（即合并Master分支之前），可能需要有一个预发布的版本进行测试。
    预发布分支是从Develop分支上边分出来的，预发布结束后，必须合并进Develop和Master分支上。
    命名采用release-*的形式：
    创建一个预发布分支：
    git checkout -b release-1.2 develop
确认没有问题后，合并Master分支：
    git checkout master
    git merge --no-ff release-1.2
    # 对合并生成的新节点，做一个标签
    git tag -a 1.2
然后合并到develop分支：
    git checkout develop
    git merge --no-ff release-1.2
最后删除预发布分支：
    git branch -d release-1.2

3. 修补bug分支：
        软件正式发布以后，难免回出现bug。这是就需要创建一个分支，进行bug修补.
        修补bug分支是从Master分支上面分出来的。修补结束后，再合并进Master和Develop分支。
    命名采用fixbug-*的形式:
        创建一个修补bug分支：
            git checkout -b fixbug-0.1 master
        修补结束后，合并到master分支：
            git checkout master
            git merge --no-ff fixbug-0.1
            git tag -a 0.1.1
        再合并到develop分支：
            git checkout develop
            git merge --no-ff fixbug-0.1
    最后，删除&quot;修补bug分支&quot;：
        git branch -d fixbug-0.1</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Gitlab</tag>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>Altium Designer 导出 Gerber 文件教程</title>
    <url>/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>输出的Gerber不是一个文件，而是一个文件集合，通常需要打包发送给厂家，厂家根据你输出的要求进行打样。基本输出的文件大概有这几个流程 Gerber Files、NC Drill Files(钻孔文件)、BOM(元器件BOM)、Generates Pick and Place Files(坐标文件)，具体步骤如下。</p>
<h4 id="2-添加钻孔表"><a href="#2-添加钻孔表" class="headerlink" title="2. 添加钻孔表"></a>2. 添加钻孔表</h4><h5 id="2-1-选中-Drill-Drawing-层"><a href="#2-1-选中-Drill-Drawing-层" class="headerlink" title="2.1 选中 Drill Drawing 层"></a>2.1 选中 Drill Drawing 层</h5><p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/DrillDrawing.png" alt></p>
<h5 id="2-2-在此层放置“-legend-”-字符"><a href="#2-2-在此层放置“-legend-”-字符" class="headerlink" title="2.2 在此层放置“ .legend ” 字符"></a>2.2 在此层放置“ .legend ” 字符</h5><ul>
<li><p>单击放置字符串</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/String.png" alt="String"></p>
</li>
<li><p>放置 “ .legend ” 字符 </p>
<ul>
<li>放置“ .legend ”字符后，在第一次输出Gerber文件的时候，会自动生产一个钻孔表，效果如 2.4 - 2 图。 </li>
</ul>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Legend.png" alt="legend"></p>
</li>
</ul>
<h5 id="2-3-字符放置效果"><a href="#2-3-字符放置效果" class="headerlink" title="2.3 字符放置效果"></a>2.3 字符放置效果</h5><p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Placetheeffect.png" alt="Place the effect"></p>
<h5 id="2-4-如果以上方法不行，该如何操作？-具体原因可能是版本问题，毕竟用的破解版的"><a href="#2-4-如果以上方法不行，该如何操作？-具体原因可能是版本问题，毕竟用的破解版的" class="headerlink" title="2.4 如果以上方法不行，该如何操作？(具体原因可能是版本问题，毕竟用的破解版的)"></a>2.4 如果以上方法不行，该如何操作？(具体原因可能是版本问题，毕竟用的破解版的)</h5><p>在Altium Designer 的菜单中选择 Place (放置) -&gt; Dirll Table(钻孔表) 。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/drilltable.png" alt="drilltable"></p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/drilltable1.png" alt="drilltable1"></p>
<h4 id="3-第一次输出（Gerber-Files）"><a href="#3-第一次输出（Gerber-Files）" class="headerlink" title="3. 第一次输出（Gerber Files）"></a>3. 第一次输出（Gerber Files）</h4><p>打开要导出的PCB，在 Altium Designer 的菜单中选择 File(文件) -&gt; Fabrication(输出制造文件) -&gt; Gerber Files。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/File-Fabrication-Gerber.png" alt="File-Fabrication-Gerber"></p>
<h5 id="3-1-Gerber-Setup-gt-General-设置"><a href="#3-1-Gerber-Setup-gt-General-设置" class="headerlink" title="3.1 Gerber Setup -&gt; General 设置"></a>3.1 Gerber Setup -&gt; General 设置</h5><p>Units (单位) 选择 <strong>Inches (英寸)</strong>；Formal (格式) 选择 <strong>2:5</strong>；根据介绍 <strong>2:3</strong> 分辨率 1mil，<strong>2:4</strong> 分辨率 0.1mil，<strong>2:5</strong> 分辨率 0.01mil；2:5 精度相对较高，本人用这个设置在多个厂家打样都没有任何问题。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/General.png" alt="General"></p>
<h5 id="3-2-Gerber-Setup-gt-Layers-设置"><a href="#3-2-Gerber-Setup-gt-Layers-设置" class="headerlink" title="3.2 Gerber Setup -&gt; Layers 设置"></a>3.2 Gerber Setup -&gt; Layers 设置</h5><p>​        单击 Plot Layers 选择 Used no 后，只要在 Layers To Plot 栏里的层都会被选中，勾选掉 Top Pad Master、Bottom Pad Master 两层，然后根据自己需要导出的层进行选择 <strong>(嘉立创现在识别版边框为 Mechanical 1 机械1层)</strong>，所以导出要选择 Mechanical 1 层；勾选 <strong>Include unconnected mid-layer pads</strong>。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Layers.png" alt="Layers"></p>
<h5 id="3-3-Gerber-Setup-gt-Drill-Drawing-设置"><a href="#3-3-Gerber-Setup-gt-Drill-Drawing-设置" class="headerlink" title="3.3 Gerber Setup -&gt; Drill Drawing 设置"></a>3.3 Gerber Setup -&gt; Drill Drawing 设置</h5><p>Drill Drawing选项卡中 需要在 <strong>Drill Drawing Plots</strong> 和 <strong>Drill Guide Plots</strong> 两个区域勾选 <strong>Plot all used drill pairs</strong></p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Drill.png" alt="Drill"></p>
<h5 id="3-4-Gerber-Setup-gt-Apertures-设置"><a href="#3-4-Gerber-Setup-gt-Apertures-设置" class="headerlink" title="3.4 Gerber Setup -&gt; Apertures 设置"></a>3.4 Gerber Setup -&gt; Apertures 设置</h5><p>在 Apertures (光圈)选项卡中勾选 Embedded apertures (RS274X) 即可。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Apertures.png" alt="Apertures"></p>
<h5 id="3-5-Gerber-Setup-gt-Advanced-设置"><a href="#3-5-Gerber-Setup-gt-Advanced-设置" class="headerlink" title="3.5 Gerber Setup -&gt; Advanced 设置"></a>3.5 Gerber Setup -&gt; Advanced 设置</h5><p>在 Advanced 选项卡中需要在 Film Size 区域中的每个选项中添加一个0; 其他的默认即合。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Advanced.png" alt="Advanced"></p>
<h5 id="3-6-Gerber-Files-输出结束后效果"><a href="#3-6-Gerber-Files-输出结束后效果" class="headerlink" title="3.6 Gerber Files 输出结束后效果"></a>3.6 Gerber Files 输出结束后效果</h5><p>第一次输出结束后自动生成 CAMtastic1.Cam*的 CAM加工文件，不用保存可以立即关闭并丢弃。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/CAM.png" alt="CAM"></p>
<h4 id="4-第二次输出（NC-Drill-Files）"><a href="#4-第二次输出（NC-Drill-Files）" class="headerlink" title="4. 第二次输出（NC Drill Files）"></a>4. 第二次输出（NC Drill Files）</h4><p>打开要导出的PCB，在 Altium Designer 的菜单中选择 File(文件) -&gt; Fabrication(输出制造文件) -&gt; NC Drill Files。</p>
<h5 id="4-1-NC-Drill-Setup-选项卡设置"><a href="#4-1-NC-Drill-Setup-选项卡设置" class="headerlink" title="4.1 NC Drill Setup 选项卡设置"></a>4.1 NC Drill Setup 选项卡设置</h5><p>通常默认设置即可，只有两个地方需要修改 —-&gt; Leading/Trailing Zeroes 区域选择 <strong>Suppress leading zeroes</strong>，默认 Suppress trailing zeroes；Other 区域勾选 <strong>Generate EIA Binary Drill File (.DRL)</strong>。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/NCDrill.png" alt="NC Drill"></p>
<h5 id="4-2-Import-Drill-Data-导入钻孔数据-窗口"><a href="#4-2-Import-Drill-Data-导入钻孔数据-窗口" class="headerlink" title="4.2 Import Drill Data (导入钻孔数据)窗口"></a>4.2 Import Drill Data (导入钻孔数据)窗口</h5><p>默认即可，不用修改，直接点击OK进行输出</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/ImportDrillData.png" alt="Import Drill Data"></p>
<h4 id="5-第三次输出（Generates-Pick-and-Place-Files）"><a href="#5-第三次输出（Generates-Pick-and-Place-Files）" class="headerlink" title="5. 第三次输出（Generates Pick and Place Files）"></a>5. 第三次输出（Generates Pick and Place Files）</h4><p>打开要导出的PCB，在 Altium Designer 的菜单中选择 File(文件) -&gt; Assembly(输出装配文件) -&gt; Generates Pick and Place Files。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Generates.png" alt="Generates"></p>
<h5 id="5-1-Pick-and-Place-Setup-设置"><a href="#5-1-Pick-and-Place-Setup-设置" class="headerlink" title="5.1 Pick and Place Setup 设置"></a>5.1 Pick and Place Setup 设置</h5><p>左边选项卡中必须要勾选的几个参数 <strong>Center-X</strong> 、<strong>Center-Y</strong>、<strong>Pad-X</strong>、<strong>Pad-Y</strong>、<strong>Ref-X</strong>、<strong>Ref-Y</strong>、<strong>Rotation</strong>，其他根据需求选择。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Generates1.png" alt="Generates1"></p>
<h5 id="5-2-坐标文件-csv-修改"><a href="#5-2-坐标文件-csv-修改" class="headerlink" title="5.2 坐标文件 .csv 修改"></a>5.2 坐标文件 .csv 修改</h5><p>删除表头文件设计信息<strong>（红线以上全部删除Delete）</strong></p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/%E5%9D%90%E6%A0%87csv%E6%96%87%E4%BB%B6.png" alt="坐标csv文件"></p>
<h4 id="6-第四次输出（PCB-BOM表）"><a href="#6-第四次输出（PCB-BOM表）" class="headerlink" title="6. 第四次输出（PCB BOM表）"></a>6. 第四次输出（PCB BOM表）</h4><p>在 Altium Designer 的菜单中选择 Reports(报告) -&gt; Bill of Materials。</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Reports.png" alt="Reports"></p>
<h5 id="6-1-Properties-gt-General-设置"><a href="#6-1-Properties-gt-General-设置" class="headerlink" title="6.1 Properties -&gt; General 设置"></a>6.1 Properties -&gt; General 设置</h5><p>设置输出文件格式</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/BOM-General.png" alt="BOM_General"></p>
<h5 id="6-2-Properties-gt-Columns设置"><a href="#6-2-Properties-gt-Columns设置" class="headerlink" title="6.2 Properties -&gt; Columns设置"></a>6.2 Properties -&gt; Columns设置</h5><p>添加<strong>Pins</strong>参数信息</p>
<p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/BOM-Columns.png" alt="BOM-Columns"></p>
<h4 id="7-Gerber-文件整理"><a href="#7-Gerber-文件整理" class="headerlink" title="7. Gerber 文件整理"></a>7. Gerber 文件整理</h4><h5 id="7-1-PCB工程文件夹下创建两个文件夹-SMT-、Gerber"><a href="#7-1-PCB工程文件夹下创建两个文件夹-SMT-、Gerber" class="headerlink" title="7.1 PCB工程文件夹下创建两个文件夹 SMT 、Gerber"></a>7.1 PCB工程文件夹下创建两个文件夹 SMT 、Gerber</h5><p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/folder.png" alt="folder"></p>
<h5 id="7-2-输出Gerber文件添加到Gerber文件夹"><a href="#7-2-输出Gerber文件添加到Gerber文件夹" class="headerlink" title="7.2 输出Gerber文件添加到Gerber文件夹"></a>7.2 输出Gerber文件添加到Gerber文件夹</h5><p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/Gerberfoler.png" alt="Gerberfoler"></p>
<h5 id="7-3-坐标文件、BOM、钢网层添加到SMT文件夹"><a href="#7-3-坐标文件、BOM、钢网层添加到SMT文件夹" class="headerlink" title="7.3 坐标文件、BOM、钢网层添加到SMT文件夹"></a>7.3 坐标文件、BOM、钢网层添加到SMT文件夹</h5><p><img src="/2020/06/28/AltiumDesigner-Gerber%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA/SMTPaste.png" alt="SMTPaste"></p>
<h4 id="8-Altium-Designer-导出-Gerber文件教程完毕"><a href="#8-Altium-Designer-导出-Gerber文件教程完毕" class="headerlink" title="8. Altium Designer 导出 Gerber文件教程完毕"></a>8. Altium Designer 导出 Gerber文件教程完毕</h4><p> <a href="http://www.linelayout.com/bbs/bbs/uploadfile/image/20140917154916101610.pdf" target="_blank" rel="noopener">参考连接</a></p>
]]></content>
      <categories>
        <category>Altium Designer</category>
        <category>Gerber</category>
      </categories>
      <tags>
        <tag>Gerber</tag>
        <tag>PCB_Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 初次运行前的配置</title>
    <url>/2020/05/07/Git%E5%88%9D%E6%AC%A1%E8%BF%90%E8%A1%8C%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<h2 id="Git初次运行配置"><a href="#Git初次运行配置" class="headerlink" title="Git初次运行配置"></a>Git初次运行配置</h2><h3 id="1-用户信息"><a href="#1-用户信息" class="headerlink" title="1.    用户信息"></a>1.    用户信息</h3><ul>
<li>安装完Git应该做的第一件事就是设置自己的用户名称和邮件地址.</li>
<li>命令如下:<ul>
<li><code>$ git config --global user.name &quot;Zhao_ch&quot;</code> </li>
<li><code>$ git config --global user.email &quot;Zhao_ch@163.com&quot;</code></li>
</ul>
</li>
<li>如果使用了–global选项，那么该命令是需要运行一次，因为之后无论你在系统上做任何事情，Git都会使用这些信息  </li>
</ul>
<h3 id="2-文本编辑器"><a href="#2-文本编辑器" class="headerlink" title="2.   文本编辑器"></a>2.   文本编辑器</h3><ul>
<li>用户信息设置完毕，可以设置默认文本编辑器  </li>
<li>如果没有设置，Git会使用操作系统默认的文本编辑器，通常是Vim </li>
<li>例如设置文本编辑器为Notepad++  <ul>
<li>命令如下：    <ul>
<li>`$ git config –global core.editor Notepad++</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-检查配置信息"><a href="#3-检查配置信息" class="headerlink" title="3.   检查配置信息"></a>3.   检查配置信息</h3><ul>
<li>如果查询配置信息可以使用 $ git config –list 命令列出所有配置信息。</li>
</ul>
<h3 id="4-生成密钥"><a href="#4-生成密钥" class="headerlink" title="4.   生成密钥"></a>4.   生成密钥</h3><ul>
<li>命令如下:<ul>
<li><code>$ ssh-keygen -t rsa -C &quot;Zhao_ch@163.com&quot;</code></li>
</ul>
</li>
<li>如果不设置密码的话 连续 3 个回车。然后生成 id_rsa 和 id_rsa.pub 两个文件。<ul>
<li><strong>Hosts文件配置 文件位置</strong> <strong>C:\Windows\System32\drivers\etc\hosts</strong>     </li>
<li>添加 35.231.145.151 <a href="http://gitlab.com/" target="_blank" rel="noopener">gitlab.com</a>   </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Github</tag>
        <tag>Gitlab</tag>
        <tag>Gitee</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/2020/05/03/Personal_Blog/</url>
    <content><![CDATA[<h1 id="青春，人生最美好的年华，相信自己，要知道你内心深处的某些东西是比任何困难都要强大。"><a href="#青春，人生最美好的年华，相信自己，要知道你内心深处的某些东西是比任何困难都要强大。" class="headerlink" title="青春，人生最美好的年华，相信自己，要知道你内心深处的某些东西是比任何困难都要强大。"></a>青春，人生最美好的年华，相信自己，要知道你内心深处的某些东西是比任何困难都要强大。</h1>]]></content>
  </entry>
  <entry>
    <title>【nRF52832】学习笔记:Flash Data Storage (FDS)存储</title>
    <url>/2020/07/11/Nordic-FDS/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<p>环境介绍</p>
<ul>
<li>操作系统:   Window10 企业版</li>
<li>IDE开发环境:   ARM_MDK5 (Keil5)</li>
<li>SDK版本:   SDK_17.0.0 </li>
<li>硬件开发板:   官方开发板 PCA10040</li>
</ul>
<a id="more"></a>

<h4 id="1-FDS概述介绍"><a href="#1-FDS概述介绍" class="headerlink" title="1.  FDS概述介绍"></a>1.  FDS概述介绍</h4><p>&emsp;&emsp;FDS (<em>Flash Data Storage</em>) 模块是用于芯片上闪存存储的一个最小文件系统，可以最大限度地降低数据损坏的风险，并简化与持久存储的交互。Nordic芯片内部FLASH的存储官方提供了两种方式，一种是 FS (<em>Flash Storage</em>)、另一种是FDS (<em>Flash Data Storage</em>) 。相对于FS (<em>Flash Storage</em>)来说，FDS (<em>Flash Data Storage</em>)对数据的组织性和安全性更强。</p>
<p>FDS模块的设计也提供了以下优点:</p>
<ul>
<li><p>通过不断验证最小化访问损坏数据的风险: </p>
<ul>
<li>在断电的情况下，数据可能写入不完整。验证确保FDS能够识别无效数据，并且不会将损坏的数据返回给用户。</li>
</ul>
</li>
<li><p>在打开记录时提供(可选的)CRC验证，以确保数据自写入以后没有改变。</p>
</li>
<li><p>最小化Flash操作(更新和删除):</p>
<ul>
<li>FDS不是删除整个页面，而是存储新数据的副本，并通过一个字写入来使过时的数据失效。</li>
</ul>
</li>
<li><p>基本损耗均衡:</p>
<ul>
<li>Flash的使用寿命是有限的，Flash具有最大可擦写次数，一旦对Flash的某个块的擦写超过最大擦写次数，这个块就会损坏。所以对Flash的擦写应该均匀的分布在快上，将块充分利用，减少擦写的次数，提高Flash的使用寿命。</li>
</ul>
</li>
<li><p>不需要复制数据就可以轻松访问数据，这使得访问数据的影响与数据大小无关。</p>
</li>
<li><p>通过灵活选择数据块的大小来最小化的使用内存。</p>
</li>
<li><p>对数据的内容不加限制 (这意味着它可以包含特殊字符) 。</p>
<p><strong>Flash数据存储支持同步读取操作和异步写入。</strong></p>
</li>
</ul>
<h4 id="2-FDS功能介绍"><a href="#2-FDS功能介绍" class="headerlink" title="2.  FDS功能介绍"></a>2.  FDS功能介绍</h4><p>&emsp;&emsp;Flash Data Storage API 公开了操作文件和记录的功能，文件由一条或多条包含实际数据的记录组成，每一条记录都由一个 <strong>KEY</strong> 标志并通过 <strong>File ID</strong> 关联到文件。File ID 和 Record Key 都不要求必须是唯一的，并且文件可以包含具有相同 Key 的多个记录，可以通过 File ID 和 Record Key 的任意组合访问记录。</p>
<p>For Example，an application could use the following two files:</p>
<ul>
<li><p>File 1 with two record:     0x1111 = “Phone1”,  0x2222 = “data:123456”</p>
</li>
<li><p>File 2 with three record:  0x1111 = “Tables1”,  0x2222 = “data:123456”,  0x2222 = “data: adcsdf”</p>
</li>
</ul>
<p>&emsp;&emsp;可以遍历File 1中的所有记录，所有Key为0x2222的记录。可以遍历File 2 中 Key 为0x1111 的记录。</p>
<h5 id="2-1-Creating-Record-创建记录"><a href="#2-1-Creating-Record-创建记录" class="headerlink" title="2.1   Creating Record (创建记录)"></a>2.1   Creating Record (创建记录)</h5><ul>
<li>新记录写入Flash时，必须提供Record Key、File ID 和 将要写入的数据。</li>
<li>更新记录 (写记录)成功后，返回一个记录描述符，可以用它来访问记录。在访问之前，等待表明写入操作成功完成的事件。</li>
</ul>
<h5 id="2-2-Manipulating-Record-处理记录"><a href="#2-2-Manipulating-Record-处理记录" class="headerlink" title="2.2   Manipulating Record (处理记录)"></a>2.2   Manipulating Record (处理记录)</h5><ul>
<li>读取、更新或者删除记录的内容，必须通过记录的描述符访问记录。首次记录写入Flash时，FDS会创建并返回一个此记录的描述符。</li>
<li>获取记录描述符函数：<ul>
<li>fds_record_find</li>
<li>fds_record_find_by_key</li>
<li>fds_record_find_in_file</li>
</ul>
</li>
<li>以上函数可以根据 Record key 和 File ID 查找记录。 </li>
<li>FDS 并没有要求 Record Key 或 File ID 是唯一的。因此，在查找记录的时候可能会找到多个匹配的记录。记路查找函数每次返回一个匹配的记录并保存当前查找的进度，返回的 Token 记录了最新匹配的记录位置，通过 Token 在接下来的查找中就可以不必从头开始，直接从 Token 记录的位置开始即可。</li>
</ul>
<h5 id="2-3-Reading-Record-读取记录"><a href="#2-3-Reading-Record-读取记录" class="headerlink" title="2.3   Reading Record (读取记录)"></a>2.3   Reading Record (读取记录)</h5><ul>
<li>读取记录可以直接在Flash中读取内容 (存储数据和元数据)，这意味着应用程序将决定时复制数据，将数据存储在 RAM 中还是在本地使用数据。</li>
<li>访问记录内容 (读取数据)，需要打开记录以检索指向记录数据和元数据存储在Flash中的位置的指针。使用 <strong>fds_record_open()</strong> 函数打开记录，<strong>fds_record_open()</strong> 函数确保在访问记录时不会修改记录或记录移动到 Flash 中的其他位置。访问记录完成后，必须关闭记录 <strong>fds_record_close()</strong> 以释放对记录的锁定。</li>
</ul>
<h5 id="2-4-Updating-Record-更新记录"><a href="#2-4-Updating-Record-更新记录" class="headerlink" title="2.4   Updating Record (更新记录)"></a>2.4   Updating Record (更新记录)</h5><ul>
<li>FDS 更新记录，即所谓的写数据。FDS 并不是将新数据写到原来的记录中去覆盖旧数据，而是创建一个新记录，然后将原有的记录作废，更新记录时，记录更新函数会返回一个新的记录描述符。</li>
<li>FDS 更新记录的方式是作废旧记录，创建新记录，更新记录频繁的话，每次都会创建新的记录，这样的话会占用Flash的空间，所以通过碎片整理收集功能来释放Flash。</li>
</ul>
<h5 id="2-5-Deleting-Record-删除记录"><a href="#2-5-Deleting-Record-删除记录" class="headerlink" title="2.5   Deleting Record (删除记录)"></a>2.5   Deleting Record (删除记录)</h5><ul>
<li>记录删除并不是真正的删除记录数据和擦除Flash空间，而是通过设置标志将需要删除的记录作废。每一条被删除的记录，就不能再对它进行打开、读、定位等相关的操作。</li>
<li>记录删除后，记录所使用的Flash空间不会立即释放，如果想要释放Flash空间，必须通过碎片收集来实现。</li>
</ul>
<h5 id="2-6-Garbage-collection-垃圾收集"><a href="#2-6-Garbage-collection-垃圾收集" class="headerlink" title="2.6   Garbage collection (垃圾收集)"></a>2.6   Garbage collection (垃圾收集)</h5><ul>
<li>不管是更新数据还是擦除数据，都会产生无效数据，这些数据都是实际存在的，占用Flash空间，因此可以调用 <strong>fds_gc()</strong> 函数API进行垃圾回收。通过执行此操作来释放这些占用Flash的无效数据。</li>
<li>垃圾收集不会自动通过FDS收集。理想情况下，应该在Ble处于低功耗的情况下进行垃圾收集，长期更新记录，产生的无效数据会将内存占满，再一次请求数据更新时，会直接返回 FDS_ERR_NO_SPACE_IN_FLASH (Flash 无空间) 错误，然后必须进行垃圾回收并等待完成后，再更新数据。</li>
</ul>
<h5 id="2-7-Restrictions-on-keys-and-IDs-FDS对-KEY-和-File-ID-的限制"><a href="#2-7-Restrictions-on-keys-and-IDs-FDS对-KEY-和-File-ID-的限制" class="headerlink" title="2.7   Restrictions on keys and IDs (FDS对 KEY 和 File ID 的限制)"></a>2.7   Restrictions on keys and IDs (FDS对 KEY 和 File ID 的限制)</h5><ul>
<li><p>Record Key 应在 0x0001 - 0xBFFF 范围内，0x0000 值是由系统保留。从 0xC000 到 0xFFFF 的值保留供Peer Manager模块使用，并且只能在不包含 Peer Manager 的应用程序中使用。</p>
</li>
<li><p>File ID 的应在0x0000 - 0xBFFF 范围内, 0xFFFF 是被系统使用的，从 0xC000 到 0xFFFE 的值保留供Peer Manager模块使用，并且只能在不包含 Peer Manager 的应用程序中使用</p>
</li>
</ul>
<h4 id="3-SDK-Config-FDS配置宏介绍"><a href="#3-SDK-Config-FDS配置宏介绍" class="headerlink" title="3.  SDK_Config  FDS配置宏介绍"></a>3.  SDK_Config  FDS配置宏介绍</h4><h5 id="3-1-FDS-VIRTUAL-PAGES"><a href="#3-1-FDS-VIRTUAL-PAGES" class="headerlink" title="3.1   FDS_VIRTUAL_PAGES"></a>3.1   FDS_VIRTUAL_PAGES</h5><ul>
<li>配置使用虚拟页的数量及其大小。</li>
<li>使用的 Flash Memory 总量取决于虚拟页的大小和数量。</li>
</ul>
<h5 id="3-2-FDS-VIRTUAL-PAGE-SIZE"><a href="#3-2-FDS-VIRTUAL-PAGE-SIZE" class="headerlink" title="3.2   FDS_VIRTUAL_PAGE_SIZE"></a>3.2   FDS_VIRTUAL_PAGE_SIZE</h5><ul>
<li>虚拟页的大小。</li>
<li>默认情况下，虚拟页与物理页大小相同。</li>
<li>虚拟页的大小必须是物理页大小的倍数。</li>
<li>已字为单位 (4-Byte)。</li>
</ul>
<h5 id="3-3-FDS-VIRTUAL-PAGES-RESERVED"><a href="#3-3-FDS-VIRTUAL-PAGES-RESERVED" class="headerlink" title="3.3   FDS_VIRTUAL_PAGES_RESERVED"></a>3.3   FDS_VIRTUAL_PAGES_RESERVED</h5><ul>
<li>其他模块使用的虚拟FLASH页数。</li>
<li>FDS模块将其数据存储在FLASH的最后一页中，通过设置此值，可以移动FDS使用的FLASH结束地地址。保留的空间可以被其他模块使用。</li>
</ul>
<h5 id="3-4-FDS-OP-QUEUE-SIZE"><a href="#3-4-FDS-OP-QUEUE-SIZE" class="headerlink" title="3.4   FDS_OP_QUEUE_SIZE"></a>3.4   FDS_OP_QUEUE_SIZE</h5><ul>
<li>FDS 程序模块内部使用的队列大小，如果FDS用户较多或者应用程序中希望一次排队更多的操作而不等待先前的操作完成，可加大队列的大小。</li>
<li>一般情况下，如果应用程序中经常接受到错误代码 FDS_ERR_NO_SPACE_IN_QUEUES,则需要增加队列大小。</li>
</ul>
<h5 id="3-5-FDS-CRC-CHECK-ON-READ"><a href="#3-5-FDS-CRC-CHECK-ON-READ" class="headerlink" title="3.5   FDS_CRC_CHECK_ON_READ"></a>3.5   FDS_CRC_CHECK_ON_READ</h5><ul>
<li>如果使能该配置项，FDS 将会启动读取操作的CRC检查 (fds_record_open)。</li>
</ul>
<h5 id="3-6-FDS-CRC-CHECK-ON-WRITE"><a href="#3-6-FDS-CRC-CHECK-ON-WRITE" class="headerlink" title="3.6   FDS_CRC_CHECK_ON_WRITE"></a>3.6   FDS_CRC_CHECK_ON_WRITE</h5><ul>
<li>可选的配置项，如果使能，FDS 写操作会进行校验。</li>
<li>使能该配置时，FDS_CRC_CHECK_ON_READ 必须打开。</li>
</ul>
<h5 id="3-7-FDS-MAX-USERS"><a href="#3-7-FDS-MAX-USERS" class="headerlink" title="3.7   FDS_MAX_USERS"></a>3.7   FDS_MAX_USERS</h5><ul>
<li>可以注册的最大回调数。</li>
<li>如果收到 FDS_ERR_USER_LIMIT_REACHED 错误，请增加此数值。</li>
</ul>
<h4 id="4-Storage-format-存储格式"><a href="#4-Storage-format-存储格式" class="headerlink" title="4.  Storage format (存储格式)"></a>4.  Storage format (存储格式)</h4><p>&emsp;&emsp;FDS 以记录的方式将数据存储到 Flash 中，这些记录被分组到文件中，在大多数用例中我们无需详细了解 FDS 如何将数据存储在 Flash 中。以下是FDS使用的数据格式相关信息，如果你对 FDS 详细信息不感兴趣，可以跳过。</p>
<h5 id="4-1-Record-layout-记录布局"><a href="#4-1-Record-layout-记录布局" class="headerlink" title="4.1   Record layout (记录布局)"></a>4.1   Record layout (记录布局)</h5><p>&emsp;&emsp;Record 由 Record Header (Record 元数据) 和实际内容组成，Record Header 用来标记Record，记录内容是实际存储的数据，它们按照如图所示的顺序连续存储在 Flash 中。</p>
<p><img src="/2020/07/11/Nordic-FDS/00_Layout_of_a_record.png" alt="Layout of a record"></p>
<h5 id="4-2-Record-header-记录头"><a href="#4-2-Record-header-记录头" class="headerlink" title="4.2   Record header (记录头)"></a>4.2   Record header (记录头)</h5><p>&emsp;&emsp;Record header 由 3个字 (12个Byte) 组成，各部分描述如下:</p>
<p><img src="/2020/07/11/Nordic-FDS/01_Record_header.png" alt="Record header"></p>
<p>&emsp;&emsp;FDS 将 Record Header 写入 Flash 中，首先写入Record Key 和数据长度，接着写入Record ID，最后写入 File ID 和 CRC 校验值，并完成成功的写入操作。检索Record的时候，FDS会忽略掉所有Record Header中第二个字美音写入的 Record，因为缺少Key意味着这条Record没有写入完整。</p>
<h5 id="4-3-Maximum-length-最大存储数据长度"><a href="#4-3-Maximum-length-最大存储数据长度" class="headerlink" title="4.3   Maximum length (最大存储数据长度)"></a>4.3   Maximum length (最大存储数据长度)</h5><p>Record 的最大长度取决于三个值:</p>
<ul>
<li>虚拟 Flash 页的大小 (FDS_VIRTUAL_PAGE_SIZE)</li>
<li>页面标记大小 (2 Words)</li>
<li>Record Header的大小 (3 Words)</li>
</ul>
<p>sdk_config.h 中默认的设置是虚拟 Flash 页的大小和物理页大小一样  (对于nRF52832来说是1024个字，即4096个字节)，对于默认值来说去掉页面标记和记录头后，最大数据长度是1019个字。</p>
<h5 id="4-4-Page-tag-页面标签"><a href="#4-4-Page-tag-页面标签" class="headerlink" title="4.4   Page tag (页面标签)"></a>4.4   Page tag (页面标签)</h5><p>&emsp;&emsp;FDS 使用的每个虚拟页面都标有一个页面标记，系统使用该标记来存储有关该页面的信息。两个字长的页面标签包含了页面用途 ( 数据存储或垃圾收集)以及页面上安装的文件系统版本的信息。</p>
<p><img src="/2020/07/11/Nordic-FDS/02_Page_tags.png" alt="Page_tags"></p>
<h4 id="5-FDS-使用方法"><a href="#5-FDS-使用方法" class="headerlink" title="5.  FDS 使用方法"></a>5.  FDS 使用方法</h4><h5 id="5-1-Initializing-the-module-初始化FDS"><a href="#5-1-Initializing-the-module-初始化FDS" class="headerlink" title="5.1   Initializing the module (初始化FDS)"></a>5.1   Initializing the module (初始化FDS)</h5><p>&emsp;&emsp;Before initializing FDS, you must initialize the SoftDevice and register a callback handler to handle FDS events. (初始化FDS之前，必须初始化SoftDevice并注册回调函数来处理FDS事件。)</p>
<p>&emsp;&emsp;以下代码区展示了如何注册FDS事件的处理函数以及如何初始化 FDS 模块:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Simple event handler to handle errors during initialization. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fds_evt_handler</span><span class="params">(<span class="keyword">fds_evt_t</span> <span class="keyword">const</span> * p_fds_evt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (p_fds_evt-&gt;id)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> FDS_EVT_INIT:</span><br><span class="line">            <span class="keyword">if</span> (p_fds_evt-&gt;result != NRF_SUCCESS)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* Initialization failed. */</span> </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ret_code_t</span> ret = fds_register(fds_evt_handler);</span><br><span class="line"><span class="keyword">if</span> (ret != NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Registering of the FDS event handler has failed. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">ret_code_t</span> ret = fds_init();</span><br><span class="line"><span class="keyword">if</span> (ret != NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle error. */</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-Writing-a-record"><a href="#5-2-Writing-a-record" class="headerlink" title="5.2   Writing a record"></a>5.2   Writing a record</h5><p>&emsp;&emsp;以下代码区展示了如何写记录:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_ID         0x0001  <span class="comment">/* The ID of the file to write the records into. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECORD_KEY_1    0x1111  <span class="comment">/* A key for the first record. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECORD_KEY_2    0x2222  <span class="comment">/* A key for the second record. */</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">uint32_t</span>   <span class="keyword">const</span> m_deadbeef = <span class="number">0xDEADBEEF</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span>       <span class="keyword">const</span> m_hello[]  = <span class="string">"Hello, world!"</span>;</span><br><span class="line"><span class="keyword">fds_record_t</span>        record;</span><br><span class="line"><span class="keyword">fds_record_desc_t</span>   record_desc;</span><br><span class="line"><span class="comment">// Set up record.</span></span><br><span class="line">record.file_id           = FILE_ID;</span><br><span class="line">record.key               = RECORD_KEY_1;</span><br><span class="line">record.data.p_data       = &amp;m_deadbeef;</span><br><span class="line">record.data.length_words = <span class="number">1</span>;   <span class="comment">/* one word is four bytes. */</span></span><br><span class="line"><span class="keyword">ret_code_t</span> rc;</span><br><span class="line">rc = fds_record_write(&amp;record_desc, &amp;record);</span><br><span class="line"><span class="keyword">if</span> (rc != NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle error. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Set up record.</span></span><br><span class="line">record.file_id           = FILE_ID;</span><br><span class="line">record.key               = RECORD_KEY_2;</span><br><span class="line">record.data.p_data       = &amp;m_hello;</span><br><span class="line"><span class="comment">/* The following calculation takes into account any eventual remainder of the division. */</span></span><br><span class="line">record.data.length_words = (<span class="keyword">sizeof</span>(m_hello) + <span class="number">3</span>) / <span class="number">4</span>;</span><br><span class="line">rc = fds_record_write(&amp;record_desc, &amp;record);</span><br><span class="line"><span class="keyword">if</span> (rc != NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Handle error. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此命令已存入队列中，并通过时间回调指示成功或失败，如果成功。fds_record_write函数将返回记录的描述符，该描述符可哦用于进一步操作记录。</p>
<h5 id="5-3-Retrieving-data"><a href="#5-3-Retrieving-data" class="headerlink" title="5.3   Retrieving data"></a>5.3   Retrieving data</h5><p>&emsp;&emsp;以下实例显示了如何查找Record功能来检索Record Key 和 File ID 匹配的所记录的记录描述符，并读取它们的数据内容。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILE_ID     0x1111</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RECORD_KEY  0x2222</span></span><br><span class="line"><span class="keyword">fds_flash_record_t</span>  flash_record;</span><br><span class="line"><span class="keyword">fds_record_desc_t</span>   record_desc;</span><br><span class="line"><span class="keyword">fds_find_token_t</span>    ftok;</span><br><span class="line"><span class="comment">/* It is required to zero the token before first use. */</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;ftok, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(<span class="keyword">fds_find_token_t</span>));</span><br><span class="line"><span class="comment">/* Loop until all records with the given key and file ID have been found. */</span></span><br><span class="line"><span class="keyword">while</span> (fds_record_find(FILE_ID, RECORD_KEY, &amp;record_desc, &amp;ftok) == NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (fds_record_open(&amp;record_desc, &amp;flash_record) != NRF_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Handle error. */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Access the record through the flash_record structure. */</span></span><br><span class="line">    <span class="comment">/* Close the record when done. */</span></span><br><span class="line">    <span class="keyword">if</span> (fds_record_close(&amp;record_desc) != NRF_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Handle error. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-Deleting-a-record"><a href="#5-4-Deleting-a-record" class="headerlink" title="5.4   Deleting a record"></a>5.4   Deleting a record</h5><p>&emsp;&emsp;以下实例显示了如何删除记录：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Assume a descriptor returned by a call to fds_record_write() or fds_record_find(),</span></span><br><span class="line"><span class="comment">   as shown in the previous example. */</span></span><br><span class="line"><span class="keyword">fds_record_desc_t</span> descriptor;</span><br><span class="line"><span class="keyword">ret_code_t</span> ret = fds_record_delete(&amp;descriptor);</span><br><span class="line"><span class="keyword">if</span> (ret != NRF_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Error. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;调fds_record_delete不会释放此记录使用的 Flash ，要回收删除记录使用的闪存空间，才能释放此记录的Flash，碎片收集运行 fds_gc()。</p>
]]></content>
      <categories>
        <category>Nordic</category>
      </categories>
      <tags>
        <tag>Nordic</tag>
        <tag>Bluetooth</tag>
        <tag>nRF52</tag>
      </tags>
  </entry>
  <entry>
    <title>Nordic_development_environment(nRF51 &amp; nRF52 Series)</title>
    <url>/2020/05/06/Nordic-development-environment/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<h3 id="1-强制安装项"><a href="#1-强制安装项" class="headerlink" title="1. 强制安装项"></a>1. 强制安装项</h3><p>​            如下工具必须安装,否则无法开发 nRF51 &amp; nRF52 Series 产品</p>
<h4 id="1-1-安装IDE"><a href="#1-1-安装IDE" class="headerlink" title="1.1   安装IDE"></a>1.1   安装IDE</h4><p>​            Nordic nRF51/52支持Keil，GCC，IAR 和 SES（Segger Embedded Studio）四种IDE，大家随便选择其中一种安装即可。</p>
<h4 id="1-2-安装-nRF-Command-Line-Tools-（支持-Windows-Linux-Mac）"><a href="#1-2-安装-nRF-Command-Line-Tools-（支持-Windows-Linux-Mac）" class="headerlink" title="1.2   安装 nRF Command Line Tools （支持 Windows / Linux / Mac）"></a>1.2   安装 nRF Command Line Tools （支持 Windows / Linux / Mac）</h4><p>​            nRF Command Line Tools ( Nordic官方自己开发的命令行工具 ) , 安装过程中具体组件包括 J-link驱动、nrfjprog、nrfutil、mergehex等。</p>
<p>​            下载连接:  <a href="https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Command-Line-Tools/Download#infotabs" target="_blank" rel="noopener">https://www.nordicsemi.com/Software-and-Tools/Development-Tools/nRF-Command-Line-Tools/Download#infotabs</a></p>
<p>​            选择自己的桌面平台及需要的版本 (推荐最新发布的版本):</p>
<p><img src="/2020/05/06/Nordic-development-environment/nRF-Command-Line-Tools.png" alt></p>
]]></content>
      <categories>
        <category>Nordic</category>
      </categories>
      <tags>
        <tag>Nordic</tag>
        <tag>Bluetooth</tag>
        <tag>nRF52</tag>
        <tag>nRF connect</tag>
        <tag>nrfutil</tag>
        <tag>nRF51</tag>
      </tags>
  </entry>
  <entry>
    <title>【STM32CubeMX】学习笔记-&gt;STM32CubeMX_Usart</title>
    <url>/2020/05/05/STM32CubeMX-Usart/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<p>环境介绍</p>
<ul>
<li>操作系统:   Window10 企业版</li>
<li>IDE开发环境:   STM32CubeIDE 1.2.0</li>
<li>STM32CubeMX版本:   STM32CubeMX Version 5.4.0</li>
<li>Mcu and Firmware Package:   STM32Cube FW_H7 V1.5.0</li>
<li>硬件开发板:   本人自己设计的最小系统</li>
</ul>
<a id="more"></a>

<h4 id="1-打开-STM32CubeMX"><a href="#1-打开-STM32CubeMX" class="headerlink" title="1. 打开 STM32CubeMX"></a>1. 打开 STM32CubeMX</h4><p><img src="/2020/05/05/STM32CubeMX-Usart/0.png" alt></p>
<p><img src="/2020/05/05/STM32CubeMX-Usart/1.png" alt></p>
<h4 id="2-创建工程Project"><a href="#2-创建工程Project" class="headerlink" title="2. 创建工程Project"></a>2. 创建工程Project</h4><p><img src="/2020/05/05/STM32CubeMX-Usart/2.png" alt></p>
<h4 id="3-选择自己MCU的型号"><a href="#3-选择自己MCU的型号" class="headerlink" title="3. 选择自己MCU的型号"></a>3. 选择自己MCU的型号</h4><ul>
<li><strong>本人MCU型号：STM32H743IITx</strong></li>
<li><strong>双击红色区域直接进入配置界面</strong></li>
</ul>
<p><img src="/2020/05/05/STM32CubeMX-Usart/3.png" alt></p>
<h4 id="4-RCC-配置"><a href="#4-RCC-配置" class="headerlink" title="4. RCC 配置"></a>4. RCC 配置</h4><ul>
<li>单击 System Core -&gt; 单击RCC<ul>
<li>RCC Mode and Configuration<ul>
<li>High Speed Clock (HSE) -&gt; Crystal/Ceramic Resonator</li>
<li>Low Speed Clock (LSE) -&gt; Crystal/Ceramic Resonator</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/05/05/STM32CubeMX-Usart/4.png" alt></p>
<h4 id="5-串口USART配置"><a href="#5-串口USART配置" class="headerlink" title="5. 串口USART配置"></a>5. 串口USART配置</h4><ul>
<li><p>单击 Connectivity -&gt; 单击 USART1</p>
<ul>
<li><p>USART1 Mode</p>
<ul>
<li>Mode：Asynchronous</li>
</ul>
</li>
<li><p>USART1 Configuration</p>
<ul>
<li>Parameter Settings（基础配置）<ul>
<li><img src="/2020/05/05/STM32CubeMX-Usart/5.png" alt></li>
</ul>
</li>
<li>NVIC Settings（中断配置）勾选Enabled<ul>
<li><img src="/2020/05/05/STM32CubeMX-Usart/6.png" alt></li>
</ul>
</li>
<li>GPIO Settings （I/O配置）<ul>
<li><strong>PA9</strong> -&gt; USART1_TX  /  <strong>PA10</strong> -&gt; UASRT1_RX</li>
<li>I/O 空闲状态全部上拉（Pull-Up）</li>
<li><img src="/2020/05/05/STM32CubeMX-Usart/7.png" alt></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="6-时钟树配置（Clock-Configuration）"><a href="#6-时钟树配置（Clock-Configuration）" class="headerlink" title="6. 时钟树配置（Clock Configuration）"></a>6. 时钟树配置（Clock Configuration）</h4><p><img src="/2020/05/05/STM32CubeMX-Usart/8.png" alt></p>
<h4 id="7-生成路径及IDE选择配置"><a href="#7-生成路径及IDE选择配置" class="headerlink" title="7. 生成路径及IDE选择配置"></a>7. 生成路径及IDE选择配置</h4><ul>
<li><p><strong>Project</strong></p>
<ul>
<li><p>Project Name：工程名（根据自己要求来写）</p>
</li>
<li><p>Project Location：生成工程路径（选择自己常用路径）</p>
</li>
<li><p>Toolchain / IDE：开发环境选择（本工程选择STM32CubeIDE开发环境）</p>
<ul>
<li>EWARM</li>
<li>MDK_ARM</li>
<li>SW4STM32</li>
<li>TrueSTUDIO</li>
<li><strong>STM32CubeIDE</strong></li>
<li>MakeFile</li>
</ul>
</li>
<li><p>Mcu and Firmware Package (STM32Cube FW_H7 V1.5.0)</p>
<ul>
<li>MCU Reference：STM32H743IITx</li>
<li>Firmware Package Name and Version：<strong>STM32Cube FW_H7 V1.5.0</strong> （版本不同，生成的工程可能会有点差异）</li>
</ul>
</li>
<li><p><img src="/2020/05/05/STM32CubeMX-Usart/9.png" alt></p>
</li>
</ul>
</li>
<li><p><strong>Code Generator 配置选择</strong> </p>
<p><img src="/2020/05/05/STM32CubeMX-Usart/10.png" alt></p>
</li>
</ul>
<p><strong>至此工程配置基本完成</strong>（单击 GENERATE CODE 生成工程）</p>
<h4 id="8-打开-STM32CubeIDE-编译生成工程"><a href="#8-打开-STM32CubeIDE-编译生成工程" class="headerlink" title="8. 打开 STM32CubeIDE 编译生成工程"></a>8. 打开 STM32CubeIDE 编译生成工程</h4><p><img src="/2020/05/05/STM32CubeMX-Usart/11.png" alt></p>
<h4 id="9-Printf-打印配置"><a href="#9-Printf-打印配置" class="headerlink" title="9. Printf 打印配置"></a>9. Printf 打印配置</h4><ul>
<li><strong>usart.h 添加代码</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br></pre></td></tr></table></figure>



<ul>
<li><strong>usart.c 添加代码</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Private function prototypes -----------------------------------------------*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __GNUC__</span></span><br><span class="line"><span class="comment">/* With GCC/RAISONANCE, small printf (option LD Linker-&gt;Libraries-&gt;Small printf</span></span><br><span class="line"><span class="comment">   set to 'Yes') calls __io_putchar() */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int __io_putchar(int ch)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __GNUC__ */</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @brief  Retargets the C library printf function to the USART.</span></span><br><span class="line"><span class="comment">  * @param  None</span></span><br><span class="line"><span class="comment">  * @retval None</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">PUTCHAR_PROTOTYPE</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Place your implementation of fputc here */</span></span><br><span class="line">    <span class="comment">/* e.g. write a character to the USART1 and Loop until the end of transmission */</span></span><br><span class="line">    HAL_UART_Transmit(&amp;huart1, (<span class="keyword">uint8_t</span> *)&amp;ch, <span class="number">1</span>, <span class="number">0xFFFF</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/05/STM32CubeMX-Usart/12.png" alt></p>
<p><img src="/2020/05/05/STM32CubeMX-Usart/13.png" alt></p>
<h4 id="10-STM32H743IITx-工程模板"><a href="#10-STM32H743IITx-工程模板" class="headerlink" title="10.  STM32H743IITx 工程模板"></a>10.  STM32H743IITx 工程模板</h4><ul>
<li>工程模板  <a href="https://gitee.com/Zhao_ch/STM32H743_Template_Cubeide" target="_blank" rel="noopener">下载连接</a></li>
</ul>
]]></content>
      <categories>
        <category>STM32CubeMX</category>
      </categories>
      <tags>
        <tag>STM32CubeMX</tag>
        <tag>STM32</tag>
        <tag>HAL</tag>
      </tags>
  </entry>
  <entry>
    <title>嘉立创JLC元件库+3D封装下载</title>
    <url>/2020/05/04/%E5%98%89%E7%AB%8B%E5%88%9BJLC%E5%85%83%E4%BB%B6%E5%BA%93-3D%E5%B0%81%E8%A3%85%E4%B8%8B%E8%BD%BD/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<h3 id="嘉立创JLC元件库-3D封装下载三种方法"><a href="#嘉立创JLC元件库-3D封装下载三种方法" class="headerlink" title="嘉立创JLC元件库+3D封装下载三种方法"></a>嘉立创JLC元件库+3D封装下载三种方法</h3><h4 id="1-下载方法1-使用Git-无需密码"><a href="#1-下载方法1-使用Git-无需密码" class="headerlink" title="1. 下载方法1:  使用Git   无需密码"></a>1. 下载方法1:  使用Git   <strong>无需密码</strong></h4><ul>
<li>Altium Designer:   <a href="https://gitee.com/JLC_SMT/JLCSMT_LIB.git" target="_blank" rel="noopener">https://gitee.com/JLC_SMT/JLCSMT_LIB.git</a>    </li>
</ul>
<h4 id="2-下载方法2：使用SVN方式-可联网同步-检出需要注册-gitee-的账号密码"><a href="#2-下载方法2：使用SVN方式-可联网同步-检出需要注册-gitee-的账号密码" class="headerlink" title="2. 下载方法2：使用SVN方式,可联网同步 检出需要注册 gitee 的账号密码"></a>2. 下载方法2：使用SVN方式,可联网同步 <strong>检出需要注册 gitee 的账号密码</strong></h4><ul>
<li>SVN端口:   <a href="svn://gitee.com/JLC_SMT/JLCSMT_LIB">svn://gitee.com/JLC_SMT/JLCSMT_LIB</a></li>
</ul>
<h4 id="3-下载方法3：手动下载-不能同步-错误无法及时修正-但可以下载"><a href="#3-下载方法3：手动下载-不能同步-错误无法及时修正-但可以下载" class="headerlink" title="3.  下载方法3：手动下载 不能同步,错误无法及时修正, 但可以下载"></a>3.  下载方法3：手动下载 不能同步,错误无法及时修正, 但可以下载</h4>]]></content>
      <categories>
        <category>Altium Designer</category>
      </categories>
      <tags>
        <tag>PCB_Design</tag>
        <tag>Altium Designer</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝牙空中升级(BLE OTA)原理与步骤</title>
    <url>/2020/06/06/%E8%93%9D%E7%89%99%E7%A9%BA%E4%B8%AD%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p>😊 转载请全文转载，并标明文章出处</p>
<a id="more"></a>

<h3 id="蓝牙空中升级-BLE-OTA-原理与步骤"><a href="#蓝牙空中升级-BLE-OTA-原理与步骤" class="headerlink" title="蓝牙空中升级(BLE OTA)原理与步骤"></a>蓝牙空中升级(BLE OTA)原理与步骤</h3><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><ul>
<li><p><strong>DFU</strong>（Device Firmware Update），设备固件升级的意思。</p>
</li>
<li><p><strong>OTA</strong>（Over The Air）是实现DFU的一种方式，准确说OTA全称应该是OTA DFU，即通过空中无线方式实现设备固件升级。</p>
</li>
<li><p>通过无线通信方式实现DFU的，都可以叫OTA，比如 2G / 3G / 4G / WIFI / 蓝牙 / NFC / Zigbee，都支持OTA。</p>
</li>
<li><p>DFU除了可以通过无线方式（OTA）进行升级，也可以通过有线方式进行升级，比如通过UART，USB或者SPI通信接口来升级设备固件。</p>
</li>
<li><p>DFU分为  <strong>后台式</strong>  与  <strong>非后台式</strong></p>
<ul>
<li><strong>后台式DFU：</strong>又称静默式DFU（Silent DFU），升级的时候，新固件在后台悄悄下载，即新固件下载属于应用程序功能的一部分，在新固件下载过程中，应用可以正常使用，也就是说整个下载过程对用户来说是无感的，下载完成后，系统再跳到Bootloader模式，由Bootloader完成新固件覆盖老固件的操作，至此整个升级过程结束。</li>
<li><strong>非后台式DFU：</strong>升级的时候，系统需要先从应用模式跳入到Bootloader模式，由Bootloader进行新固件下载工作，下载完成后Bootloader继续完成新固件覆盖老固件的操作，至此升级结束。早先的功能机就是采用非后台式 DFU来升级操作系统的，即用户需要先长按某些按键进入Bootloader模式，然后再进行升级，整个升级过程中手机正常功能都无法使用。</li>
</ul>
</li>
<li><p><strong>双区DFU</strong>（Dual bank）和<strong>单区DFU</strong>（Single bank），<strong>双区或者单区DFU式新固件和老固件覆盖的两种方式</strong>。</p>
<ul>
<li><p><strong>后台式DFU（双区模式）：</strong>必须采用双区模式进行升级，即老系统（老固件）和新系统（新固件）各占一块Bank（存储区），假设老固件放在Bank0中，新固件放在Bank1中，升级的时候，应用程序先把新固件下载到Bank1中，只有当新固件下载完成并校验成功后，系统才会跳进Bootloader模式，然后擦除老固件所在的Bank0区，并把新固件拷贝到Bank0区中。</p>
</li>
<li><p><strong>非后台式DFU：</strong>可以采用双区模式，也可以采用单区模式</p>
<ul>
<li><p>非后台式DFU（双区模式）：双区模式下新老固件各占一块Bank（老固件为Bank0，新固件为Bank1），升级时，系统先跳入Bootloader模式，然后Bootloader程序把新固件下载到bank1中，只有新固件下载完成并校验成功后，才会去擦除老固件所在的bank0区，并把新固件拷贝到bank0区</p>
</li>
<li><p>非后台式DFU（单区模式）：单区模式的非后台式DFU只有一个Bank0，老固件和新固件分享这一个bank0，升级的时候，进入bootloader模式后<strong>立马擦除老固件</strong>，然后直接把新固件下载到同一个bank中，下载完成后校验新固件的有效性，新固件有效升级完成，否则要求重来。（跟非后台式DFU双区模式相比，单区模式节省了一个Bank的Flash空间，在系统资源比较紧张的时候，单区模式是一个不错的选择）</p>
<p>（不管是双区模式还是单区模式，升级过程出现问题后，都可以进行二次升级，都不会出现“变砖”情况。不过双区模式有一个好处，如果升级过程中出现问题或者新固件有问题，它还可以选择之前的老固件老系统继续执行而不受其影响。而单区模式碰到这种情况就只能一直待在bootloader中，然后等待二次或者多次升级尝试，此时设备的正常功能已无法使用，从用户使用这个角度来说，你的确可以说此时设备已经“变砖”了。所以说，虽然双区模式牺牲了很多存储空间，但是换来了更好的升级体验。）</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/2020/06/06/%E8%93%9D%E7%89%99%E7%A9%BA%E4%B8%AD%E5%8D%87%E7%BA%A7/%E5%8D%87%E7%BA%A7%E5%9B%BE%E8%A7%A3.png" alt></p>
<h4 id="二、Nordic-SDK-DFU工作原理"><a href="#二、Nordic-SDK-DFU工作原理" class="headerlink" title="二、Nordic SDK DFU工作原理"></a>二、Nordic SDK DFU工作原理</h4><p><img src="/2020/06/06/%E8%93%9D%E7%89%99%E7%A9%BA%E4%B8%AD%E5%8D%87%E7%BA%A7/nRF_SDK%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84.png" alt></p>
<ul>
<li><p><strong>采用双区模式：</strong>Bank0存放的是D程序（老固件），Bank1存放的是新固件。应用程序只在Bank0里跑，Bank1平时为空或者忽略，升级时，先跳转到Bootloader，然后接收新固件并放在Bank1中，最后把Bank1里边的固件拷贝到Bank0中。</p>
</li>
<li><p><strong>采用单区模式：</strong>单区模式则没有Bank1存储区，系统只跑Bank0里面的代码，升级的时候，先跳转到Bootloader，先擦除Bank0里面的程序（老固件），并把新固件直接放在Bank0中。</p>
</li>
</ul>
<p>  <strong>升级时如何跳转到Bootloader？</strong></p>
<p>  ​        Nordic SDK 将DFU分为按键式DFU和非按键式DFU，按键式DFU是上电时长按某按键进入Bootloader模式。非按键式是整个DFU过程中设备端无任何人工干预，通过BLE/UART/USB接口给应用程序发送一条指令，应用程序收到指令后自动进入Bootloader模式。不管是什么方式进入Bootloader，Bootloader工作过程都是一样的。</p>
<p>  <strong>跳转到Bootloader后的执行操作</strong></p>
<p>  ​        程序跳转到Bootloader后，根据Bootloader需不需要对新固件进行验签。（DFU分为开放式DFU和安全式DFU）</p>
<p>  ​        <strong>开放式DFU：</strong> Bootloader不做任何验证，直接把新固件进行升级。</p>
<p>  ​        <strong>安全式DFU：</strong> Bootloader存有一把公钥，Bootloader会先把公钥验证新固件的签名，验签通过，允许后续的工作。（如果验签失败，Bootloader将拒绝升级，重新跳回应用程序）</p>
<p>  目前SDK支持Bluetooth、UART、USB三种方式接受新固件，官方SDK中可以找到此三种方式的工程目录。</p>
<p>  nRF51/52启动流程：<br>          系统上电之后，系统先执行Softdevice，Softdevice通过读取UICR寄存器的一个值，来判断系统目前是否有Bootloader，如果没有Bootloader，系统直接跳到Application；如果有Bootloader，系统先跳到Bootloader，Bootloader再根据相关情况来决定是进入升级模式还是进入Application。<br>          <strong>Bootloader主要判断如下几种情况：<br>                  按键是否按下（按键进入Bootloader DFU）<br>                  保持寄存器GPREGRET1是否为 0xB1<br>                  上次DFU过程是否还在进行<br>                  应用程序校验是否通过</strong></p>
]]></content>
      <categories>
        <category>Nordic</category>
      </categories>
      <tags>
        <tag>Nordic</tag>
        <tag>Bluetooth</tag>
        <tag>nRF52</tag>
        <tag>nRF connect</tag>
        <tag>nrfutil</tag>
        <tag>nRF51</tag>
      </tags>
  </entry>
</search>
